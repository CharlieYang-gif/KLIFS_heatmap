<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Kinase IFP Heatmap Tool_V2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Plotly for heatmap -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <!-- SheetJS for reading Excel -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 1rem 2rem;
      background: #f5f5f5;
    }
    h1 {
      margin-top: 0;
    }
    .panel {
      background: #ffffff;
      border-radius: 12px;
      padding: 1rem 1.5rem;
      margin-bottom: 1rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }
    label {
      font-weight: 600;
    }
    input[type="number"], select, textarea {
      padding: 0.25rem 0.4rem;
      border-radius: 6px;
      border: 1px solid #ccc;
      font-family: inherit;
      font-size: 0.9rem;
    }
    input[type="file"] {
      margin-top: 0.25rem;
    }
    button {
      padding: 0.4rem 0.8rem;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      background: #1f7ae0;
      color: white;
      font-weight: 600;
      margin-right: 0.5rem;
      margin-top: 0.5rem;
    }
    button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }
    .flex-row {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
    }
    .field {
      margin-bottom: 0.5rem;
    }
    .field small {
      display: block;
      color: #666;
      font-weight: 400;
    }
    #heatmap {
      width: 100%;
      height: 600px;
      background: #ffffff;
      border-radius: 12px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      max-height: 300px;
      overflow-y: auto;
      display: block;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 4px 6px;
      font-size: 12px;
      white-space: nowrap;
    }
    th {
      background: #f0f0f0;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .checkbox-row {
      display: flex;
      align-items: center;
      gap: 0.3rem;
    }
    .dual-list-container {
      display: flex;
      gap: 1rem;
      align-items: flex-start;
      flex-wrap: wrap;
    }
    .dual-list-column {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
    }
    .dual-list-buttons {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      margin-top: 1.5rem;
    }
    .dual-list-select {
      min-width: 180px;
      min-height: 180px;
    }
    .search-input {
      width: 100%;
      box-sizing: border-box;
    }
    textarea {
      width: 100%;
      box-sizing: border-box;
      min-height: 80px;
    }
    .muted {
      color: #666;
      font-size: 0.85rem;
    }
  </style>
</head>
<body>
  <h1>Kinase Interaction Fingerprint Heatmap</h1>

  <div class="panel">
    <h2>1. 上傳檔案與設定</h2>
    <div class="field">
      <label>上傳 KLIFS IFP Excel 檔（.xlsx）</label><br />
      <input type="file" id="fileInput" accept=".xlsx" />
    </div>

    <div class="flex-row">
      <div class="field">
        <div class="checkbox-row">
          <input type="checkbox" id="collapseHpHb" checked />
          <label for="collapseHpHb">將 IFP_type 1–3 / 4–7 整合為 HP/HB</label>
        </div>
        <small>打勾：用 position-HP / position-HB；取消：用原始 IFP bits（下載的 CSV 會保留原始前 5 行）。</small>
      </div>

      <div class="field">
        <label for="metaRows">Meta 列數</label><br />
        <input type="number" id="metaRows" value="5" min="1" max="20" />
        <small>依你目前檔案格式，預設是 5 行 meta。</small>
      </div>

      <div class="field">
        <label for="metaCols">Meta 欄數</label><br />
        <input type="number" id="metaCols" value="5" min="1" max="20" />
        <small>預設前 5 欄：RowID, structure_ID, kinase, kinase_ID, pdb。</small>
      </div>

      <div class="field">
        <label for="ifpStartCol">IFP 起始欄 index</label><br />
        <input type="number" id="ifpStartCol" value="5" min="0" max="100" />
        <small>0=A 欄，5=第 6 欄 (F)。</small>
      </div>
    </div>

    <button id="processBtn" disabled>執行分析</button>
    <span id="statusText"></span>
  </div>

  <div class="panel">
    <h2>2. 選擇要畫圖的 kinase</h2>
    <div class="dual-list-container">
      <div class="dual-list-column" style="flex:1;">
        <label>未選擇的 kinase</label>
        <input type="text" id="kinaseSearch" class="search-input" placeholder="搜尋 kinase..." />
        <select id="availableKinases" multiple class="dual-list-select"></select>
      </div>

      <div class="dual-list-buttons">
        <button id="addKinaseBtn">&gt;&gt;</button>
        <button id="removeKinaseBtn">&lt;&lt;</button>
      </div>

      <div class="dual-list-column" style="flex:1;">
        <label>已選擇的 kinase</label>
        <select id="selectedKinases" multiple class="dual-list-select"></select>
      </div>
    </div>
    <div class="muted">提示：可用搜尋框過濾左側列表。雙擊左側項目可移到右側，雙擊右側項目可移回左側。</div>
    <button id="updatePlotBtn" disabled>更新 heatmap</button>
  </div>

  <div class="panel">
    <h2>3. 逐 kinase 發生率表預覽</h2>
    <div id="tableContainer"></div>
  </div>

  <div class="panel">
    <h2>4. Heatmap 預覽與下載</h2>
    <div id="heatmap"></div>
    <button id="downloadExcelBtn" disabled>下載結果 Excel（CSV）</button>
    <button id="downloadPngBtn" disabled>下載 heatmap 圖檔（PNG）</button>
  </div>

  <div class="panel">
    <h2>5. Double-check 工具</h2>
    <p class="muted">
      使用方式：從原始 Excel 複製兩行貼上：<br />
      第 1 行：IFP_name 那一列（例如 0-1, 0-2, ...）<br />
      第 2 行：某一個 PDB 的資料列（包含 0/1）。<br />
      會針對該 PDB 所屬的 kinase，檢查目前輸出矩陣中「值為 0」的欄位是否與貼上的原始資料一致（都為 0）。
    </p>
    <div class="field">
      <label>貼上 IFP_name 那一行</label>
      <textarea id="dcIfpNameRow" placeholder="直接貼上整行 IFP_name ..."></textarea>
    </div>
    <div class="field">
      <label>貼上某一個 PDB 的資料列</label>
      <textarea id="dcPdbRow" placeholder="直接貼上某一列 PDB 的原始資料 ..."></textarea>
    </div>
    <button id="doubleCheckBtn" disabled>執行 double-check</button>
    <div id="dcResult" class="muted" style="margin-top:0.5rem;"></div>
  </div>

  <script>
    let rawData = null;              // 2D array from Excel
    let kinaseFreqMatrix = null;     // Array of row objects: {kinase: ..., feature1: ..., ...}
    let featureNames = [];           // feature columns
    let kinaseNames = [];            // all kinases in result
    const kinaseKeyName = "kinase";  // 依你原始欄位第 3 欄是 kinase

    // 保留一些設定與狀態
    let lastCollapseMode = true;        // true = HP/HB 模式, false = raw bits 模式
    let lastMetaRows = 5;
    let lastMetaCols = 5;
    let lastIfpStartCol = 5;

    const fileInput = document.getElementById("fileInput");
    const processBtn = document.getElementById("processBtn");
    const collapseHpHbCheckbox = document.getElementById("collapseHpHb");
    const metaRowsInput = document.getElementById("metaRows");
    const metaColsInput = document.getElementById("metaCols");
    const ifpStartColInput = document.getElementById("ifpStartCol");
    const statusText = document.getElementById("statusText");
    const availableKinasesSelect = document.getElementById("availableKinases");
    const selectedKinasesSelect = document.getElementById("selectedKinases");
    const kinaseSearchInput = document.getElementById("kinaseSearch");
    const addKinaseBtn = document.getElementById("addKinaseBtn");
    const removeKinaseBtn = document.getElementById("removeKinaseBtn");
    const updatePlotBtn = document.getElementById("updatePlotBtn");
    const tableContainer = document.getElementById("tableContainer");
    const downloadExcelBtn = document.getElementById("downloadExcelBtn");
    const downloadPngBtn = document.getElementById("downloadPngBtn");

    const dcIfpNameRow = document.getElementById("dcIfpNameRow");
    const dcPdbRow = document.getElementById("dcPdbRow");
    const doubleCheckBtn = document.getElementById("doubleCheckBtn");
    const dcResult = document.getElementById("dcResult");

    // Excel 上傳
    fileInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) {
        rawData = null;
        processBtn.disabled = true;
        return;
      }
      const reader = new FileReader();
      reader.onload = (evt) => {
        const data = new Uint8Array(evt.target.result);
        const workbook = XLSX.read(data, { type: "array" });
        const firstSheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[firstSheetName];
        rawData = XLSX.utils.sheet_to_json(worksheet, {
          header: 1,
          raw: true,
          defval: null
        });
        processBtn.disabled = false;
        statusText.textContent = " 檔案讀取成功，可以執行分析。";
      };
      reader.readAsArrayBuffer(file);
    });

    // 主分析按鈕
    processBtn.addEventListener("click", () => {
      if (!rawData) return;
      const nMetaRows = parseInt(metaRowsInput.value, 10) || 5;
      const nMetaCols = parseInt(metaColsInput.value, 10) || 5;
      const ifpStartCol = parseInt(ifpStartColInput.value, 10) || 5;
      const collapse = collapseHpHbCheckbox.checked;

      lastCollapseMode = collapse;
      lastMetaRows = nMetaRows;
      lastMetaCols = nMetaCols;
      lastIfpStartCol = ifpStartCol;

      statusText.textContent = " 計算中...";
      setTimeout(() => {
        try {
          const structRows = collapse
            ? collapseToHpHb(rawData, nMetaRows, nMetaCols, ifpStartCol)
            : useRawIfpBits(rawData, nMetaRows, nMetaCols, ifpStartCol);

          const result = computeKinaseFrequency(structRows, kinaseKeyName, nMetaCols);
          kinaseFreqMatrix = result.rows;
          kinaseNames = result.kinases;
          featureNames = result.features;

          fillKinaseLists(kinaseNames);
          renderTablePreview(kinaseFreqMatrix, featureNames);
          drawHeatmap(kinaseFreqMatrix, featureNames, kinaseNames);

          updatePlotBtn.disabled = false;
          downloadExcelBtn.disabled = false;
          downloadPngBtn.disabled = false;
          doubleCheckBtn.disabled = false;
          statusText.textContent = " 分析完成。";
        } catch (err) {
          console.error(err);
          statusText.textContent = " 錯誤：" + err.message;
        }
      }, 10);
    });

    // 兩個 list 之間移動
    function moveSelected(fromSelect, toSelect) {
      const selectedOptions = Array.from(fromSelect.selectedOptions);
      selectedOptions.forEach(opt => {
        // 避免重複
        const exists = Array.from(toSelect.options).some(o => o.value === opt.value);
        if (!exists) {
          const newOpt = document.createElement("option");
          newOpt.value = opt.value;
          newOpt.textContent = opt.textContent;
          toSelect.appendChild(newOpt);
        }
        fromSelect.removeChild(opt);
      });
    }

    addKinaseBtn.addEventListener("click", () => {
      moveSelected(availableKinasesSelect, selectedKinasesSelect);
    });

    removeKinaseBtn.addEventListener("click", () => {
      moveSelected(selectedKinasesSelect, availableKinasesSelect);
    });

    // 雙擊移動
    availableKinasesSelect.addEventListener("dblclick", () => {
      moveSelected(availableKinasesSelect, selectedKinasesSelect);
    });

    selectedKinasesSelect.addEventListener("dblclick", () => {
      moveSelected(selectedKinasesSelect, availableKinasesSelect);
    });

    // 搜尋過濾左側列表
    kinaseSearchInput.addEventListener("input", () => {
      if (!kinaseNames || kinaseNames.length === 0) return;
      const query = kinaseSearchInput.value.trim().toLowerCase();
      // 保留右側已選
      const selectedValues = Array.from(selectedKinasesSelect.options).map(o => o.value);
      // 重新填左側，過濾 + 排除已選
      availableKinasesSelect.innerHTML = "";
      kinaseNames
        .filter(k => !selectedValues.includes(k))
        .filter(k => k.toLowerCase().includes(query))
        .forEach(k => {
          const opt = document.createElement("option");
          opt.value = k;
          opt.textContent = k;
          availableKinasesSelect.appendChild(opt);
        });
    });

    function getSelectedKinaseNames() {
      return Array.from(selectedKinasesSelect.options).map(o => o.value);
    }

    // 更新 heatmap 按鈕
    updatePlotBtn.addEventListener("click", () => {
      if (!kinaseFreqMatrix) return;
      const selected = getSelectedKinaseNames();
      let rowsToUse;
      let namesToUse;
      if (selected.length === 0) {
        rowsToUse = kinaseFreqMatrix;
        namesToUse = kinaseNames;
      } else {
        rowsToUse = kinaseFreqMatrix.filter(r => selected.includes(r[kinaseKeyName]));
        namesToUse = rowsToUse.map(r => r[kinaseKeyName]);
      }
      renderTablePreview(rowsToUse, featureNames);
      drawHeatmap(rowsToUse, featureNames, namesToUse);
    });

    // 下載結果 CSV
    downloadExcelBtn.addEventListener("click", () => {
      if (!kinaseFreqMatrix) return;
      const csv = matrixToCsv(
        kinaseFreqMatrix,
        featureNames,
        kinaseKeyName,
        lastCollapseMode,
        rawData,
        lastMetaRows,
        lastMetaCols,
        lastIfpStartCol
      );
      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "kinase_interaction_frequency.csv";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // 下載 PNG 圖檔
    downloadPngBtn.addEventListener("click", () => {
      Plotly.toImage("heatmap", { format: "png", height: 600, width: 1200 })
        .then((dataUrl) => {
          const a = document.createElement("a");
          a.href = dataUrl;
          a.download = "kinase_heatmap.png";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        })
        .catch((err) => {
          console.error(err);
          alert("產生 PNG 時發生錯誤，請開 F12 看 console。");
        });
    });

    // Double-check
    doubleCheckBtn.addEventListener("click", () => {
      dcResult.textContent = "";
      if (!kinaseFreqMatrix || !rawData) {
        dcResult.textContent = "請先上傳檔案並執行分析。";
        return;
      }
      const ifpRowText = dcIfpNameRow.value.trim();
      const pdbRowText = dcPdbRow.value.trim();
      if (!ifpRowText || !pdbRowText) {
        dcResult.textContent = "請貼上 IFP_name 與 PDB 資料兩行。";
        return;
      }

      const nMetaCols = lastMetaCols;
      const ifpStartCol = lastIfpStartCol;

      const ifpTokens = parseRowToArray(ifpRowText);
      const pdbTokens = parseRowToArray(pdbRowText);

      if (ifpTokens.length <= ifpStartCol || pdbTokens.length <= ifpStartCol) {
        dcResult.textContent = "貼上的列欄數看起來不夠，請確認有包含 IFP 的所有欄位。";
        return;
      }

      // 取得 kinase 名稱（假設在第 3 欄）
      const kinaseNameFromRow = pdbTokens[2];
      const targetRow = kinaseFreqMatrix.find(r => r[kinaseKeyName] === kinaseNameFromRow);
      if (!targetRow) {
        dcResult.textContent = `在輸出矩陣中找不到 kinase：${kinaseNameFromRow}`;
        return;
      }

      const collapse = lastCollapseMode;
      if (!collapse) {
        const report = doubleCheckRawBits(
          targetRow,
          featureNames,
          ifpTokens,
          pdbTokens,
          ifpStartCol
        );
        dcResult.innerHTML = report;
      } else {
        const report = doubleCheckHpHb(
          targetRow,
          featureNames,
          ifpTokens,
          pdbTokens,
          ifpStartCol
        );
        dcResult.innerHTML = report;
      }
    });

    // ---------- 資料處理邏輯 ----------

    function collapseToHpHb(data, nMetaRows, nMetaCols, ifpStartCol) {
      const positionRow = data[1].slice(ifpStartCol);
      const ifpTypeRow = data[2].slice(ifpStartCol);
      const headerRow = data[0];

      const hpTypes = new Set([1, 2, 3]);
      const hbTypes = new Set([4, 5, 6, 7]);

      const posToHpCols = {};
      const posToHbCols = {};

      for (let j = 0; j < positionRow.length; j++) {
        const pos = positionRow[j];
        const t = ifpTypeRow[j];
        const colIdx = ifpStartCol + j;
        if (pos == null || t == null || pos === "" || t === "") continue;

        const posInt = parseInt(pos, 10);
        const tInt = parseInt(t, 10);
        if (!Number.isFinite(posInt) || !Number.isFinite(tInt)) continue;

        if (!posToHpCols[posInt]) posToHpCols[posInt] = [];
        if (!posToHbCols[posInt]) posToHbCols[posInt] = [];

        if (hpTypes.has(tInt)) {
          posToHpCols[posInt].push(colIdx);
        } else if (hbTypes.has(tInt)) {
          posToHbCols[posInt].push(colIdx);
        }
      }

      const allPositions = Array.from(new Set([
        ...Object.keys(posToHpCols).map(Number),
        ...Object.keys(posToHbCols).map(Number),
      ])).sort((a, b) => a - b);

      const metaColNames = headerRow.slice(0, nMetaCols);

      const structRows = [];
      for (let i = nMetaRows; i < data.length; i++) {
        const row = data[i];
        if (!row || row.every(v => v == null || v === "")) continue;

        const obj = {};
        for (let c = 0; c < nMetaCols; c++) {
          const colName = metaColNames[c] || `col${c}`;
          obj[colName] = row[c];
        }

        for (const pos of allPositions) {
          const hpCols = posToHpCols[pos] || [];
          const hbCols = posToHbCols[pos] || [];

          let hpValue = 0;
          let hbValue = 0;

          if (hpCols.length > 0) {
            for (const idx of hpCols) {
              const v = row[idx];
              const num = Number(v);
              if (Number.isFinite(num) && num > 0) {
                hpValue = 1;
                break;
              }
            }
          }
          if (hbCols.length > 0) {
            for (const idx of hbCols) {
              const v = row[idx];
              const num = Number(v);
              if (Number.isFinite(num) && num > 0) {
                hbValue = 1;
                break;
              }
            }
          }

          obj[`${pos}-HP`] = hpValue;
          obj[`${pos}-HB`] = hbValue;
        }

        structRows.push(obj);
      }

      return structRows;
    }

    function useRawIfpBits(data, nMetaRows, nMetaCols, ifpStartCol) {
      const headerRow = data[0];
      const structRows = [];

      for (let i = nMetaRows; i < data.length; i++) {
        const row = data[i];
        if (!row || row.every(v => v == null || v === "")) continue;

        const obj = {};
        for (let c = 0; c < headerRow.length; c++) {
          const colName = headerRow[c] || `col${c}`;
          let v = row[c];
          if (c >= ifpStartCol) {
            v = Number(v);
            if (!Number.isFinite(v)) v = 0;
          }
          obj[colName] = v;
        }
        structRows.push(obj);
      }
      return structRows;
    }

    function computeKinaseFrequency(structRows, kinaseColName, nMetaCols) {
      const groups = {};
      for (const row of structRows) {
        const k = row[kinaseColName];
        if (k == null || k === "") continue;
        if (!groups[k]) groups[k] = [];
        groups[k].push(row);
      }

      const kinases = Object.keys(groups).sort();

      const exampleRow = structRows[0] || {};
      const allKeys = Object.keys(exampleRow);
      const metaCandidate = ["RowID", "structure_ID", "kinase", "kinase_ID", "pdb"];
      const featureCols = allKeys.filter(k => !metaCandidate.includes(k));

      const resultRows = [];

      for (const k of kinases) {
        const rows = groups[k];
        const outRow = {};
        outRow[kinaseColName] = k;

        for (const col of featureCols) {
          let sum = 0;
          let count = 0;
          for (const r of rows) {
            const v = Number(r[col]);
            if (Number.isFinite(v)) {
              sum += v;
              count += 1;
            }
          }
          const mean = count > 0 ? (sum / count) * 100 : 0;
          outRow[col] = mean;
        }

        resultRows.push(outRow);
      }

      return {
        rows: resultRows,
        kinases,
        features: featureCols
      };
    }

    // ---------- UI Helper ----------

    function fillKinaseLists(kinaseNamesList) {
      availableKinasesSelect.innerHTML = "";
      selectedKinasesSelect.innerHTML = "";
      kinaseNamesList.forEach(k => {
        const opt = document.createElement("option");
        opt.value = k;
        opt.textContent = k;
        availableKinasesSelect.appendChild(opt);
      });
      kinaseSearchInput.value = "";
    }

    function renderTablePreview(rows, featureNames, maxRows = 50) {
      if (!rows || rows.length === 0) {
        tableContainer.innerHTML = "<p>沒有資料可顯示。</p>";
        return;
      }

      const cols = [kinaseKeyName, ...featureNames];
      const limitedRows = rows.slice(0, maxRows);

      let html = "<table><thead><tr>";
      cols.forEach(c => {
        html += `<th>${escapeHtml(c)}</th>`;
      });
      html += "</tr></thead><tbody>";

      for (const r of limitedRows) {
        html += "<tr>";
        cols.forEach(c => {
          const v = r[c];
          const text = (typeof v === "number")
            ? v.toFixed(1)
            : (v == null ? "" : String(v));
          html += `<td>${escapeHtml(text)}</td>`;
        });
        html += "</tr>";
      }

      html += "</tbody></table>";
      if (rows.length > maxRows) {
        html += `<p>（只顯示前 ${maxRows} 列，實際共有 ${rows.length} 列。）</p>`;
      }

      tableContainer.innerHTML = html;
    }

    function drawHeatmap(rows, features, names) {
      if (!rows || rows.length === 0) {
        Plotly.purge("heatmap");
        return;
      }
      const z = rows.map(r => features.map(f => Number(r[f]) || 0));
      const y = rows.map(r => r[kinaseKeyName]);
      const x = features;

      const data = [{
        z,
        x,
        y,
        type: "heatmap",
        colorscale: "Viridis",
        colorbar: { title: "Frequency (%)" },
        zmin: 0
      }];

      const layout = {
        title: "Kinase Interaction Frequency Heatmap (%)",
        xaxis: { title: "Interaction Features", tickangle: -90 },
        yaxis: { title: "Kinase" },
        margin: { l: 120, r: 20, t: 40, b: 150 }
      };

      Plotly.newPlot("heatmap", data, layout, { responsive: true });
    }

    function matrixToCsv(rows, features, kinaseKey, collapseMode, rawData, nMetaRows, nMetaCols, ifpStartCol) {
      const lines = [];

      // 若是不整合 HP/HB（raw bits），在最前面保留原始前 5 行
      if (!collapseMode && rawData) {
        const maxCols = rawData.reduce((m, r) => Math.max(m, r.length), 0);
        for (let i = 0; i < nMetaRows && i < rawData.length; i++) {
          const row = rawData[i];
          const padded = [];
          for (let c = 0; c < maxCols; c++) {
            let v = row[c];
            if (v == null) v = "";
            const s = String(v).replace(/"/g, '""');
            padded.push(`"${s}"`);
          }
          lines.push(padded.join(","));
        }
        // 空一行
        lines.push("");
      }

      const headers = [kinaseKey, ...features];
      lines.push(headers.join(","));
      for (const r of rows) {
        const row = [r[kinaseKey]];
        for (const f of features) {
          let v = r[f];
          if (typeof v === "number") v = v.toFixed(4);
          if (v == null) v = "";
          const s = String(v).replace(/"/g, '""');
          row.push(`"${s}"`);
        }
        lines.push(row.join(","));
      }
      return lines.join("\n");
    }

    function parseRowToArray(text) {
      // 嘗試用 tab 分隔，若沒有 tab 再用逗號
      if (text.includes("\t")) {
        return text.split("\t").map(s => s.trim());
      } else {
        return text.split(",").map(s => s.trim());
      }
    }

    function doubleCheckRawBits(targetRow, features, ifpTokens, pdbTokens, ifpStartCol) {
      const tol = 1e-8;
      let checked = 0;
      let mismatches = [];

      for (let j = 0; j < features.length; j++) {
        const feat = features[j];
        const outVal = Number(targetRow[feat]);
        if (!Number.isFinite(outVal)) continue;

        if (Math.abs(outVal) < tol) {
          // 輸出為 0，檢查原始 row
          const idxInRaw = ifpStartCol + j;
          const bitStr = pdbTokens[idxInRaw];
          const bitVal = Number(bitStr);
          if (Number.isFinite(bitVal)) {
            checked++;
            if (bitVal !== 0) {
              mismatches.push({
                feature: feat,
                bit: bitVal
              });
            }
          }
        }
      }

      let html = `Raw bits 模式：檢查了輸出為 0 的 feature 共 ${checked} 個。<br/>`;
      if (mismatches.length === 0) {
        html += `<span style="color:green;">所有輸出為 0 的 feature，在貼上的那一列中也都是 0（未發現不一致）。</span>`;
      } else {
        html += `<span style="color:red;">發現 ${mismatches.length} 個不一致的欄位，前幾個例子：</span><br/>`;
        mismatches.slice(0, 10).forEach(m => {
          html += `feature=${escapeHtml(m.feature)}，貼上的原始 bit=${m.bit}<br/>`;
        });
      }
      return html;
    }

    function doubleCheckHpHb(targetRow, features, ifpTokens, pdbTokens, ifpStartCol) {
      const tol = 1e-8;
      let checked = 0;
      let mismatches = [];

      // 先把貼上的 IFP_name row 分解成 position/type
      const ifpNameParts = [];
      for (let j = ifpStartCol; j < ifpTokens.length; j++) {
        const name = ifpTokens[j];
        if (!name) {
          ifpNameParts.push(null);
          continue;
        }
        const parts = name.split("-");
        if (parts.length !== 2) {
          ifpNameParts.push(null);
          continue;
        }
        const pos = parseInt(parts[0], 10);
        const t = parseInt(parts[1], 10);
        if (!Number.isFinite(pos) || !Number.isFinite(t)) {
          ifpNameParts.push(null);
          continue;
        }
        ifpNameParts.push({ pos, type: t, colIndex: j });
      }

      for (const feat of features) {
        const outVal = Number(targetRow[feat]);
        if (!Number.isFinite(outVal)) continue;

        if (Math.abs(outVal) < tol) {
          // feat 形如 "1-HP" 或 "1-HB"
          const parts = feat.split("-");
          if (parts.length !== 2) continue;
          const pos = parseInt(parts[0], 10);
          const suffix = parts[1]; // "HP" or "HB"
          if (!Number.isFinite(pos)) continue;

          const typesToCheck = suffix === "HP" ? [1, 2, 3] : [4, 5, 6, 7];

          let allZero = true;
          let anyChecked = false;

          for (let idx = 0; idx < ifpNameParts.length; idx++) {
            const info = ifpNameParts[idx];
            if (!info) continue;
            if (info.pos !== pos) continue;
            if (!typesToCheck.includes(info.type)) continue;

            const colIndex = info.colIndex;
            const bitStr = pdbTokens[colIndex];
            const bitVal = Number(bitStr);
            if (Number.isFinite(bitVal)) {
              anyChecked = true;
              if (bitVal !== 0) {
                allZero = false;
                mismatches.push({
                  feature: feat,
                  ifpName: `${info.pos}-${info.type}`,
                  bit: bitVal
                });
              }
            }
          }

          if (anyChecked) {
            checked++;
          }
        }
      }

      let html = `HP/HB 模式：檢查了輸出為 0 的 HP/HB 欄位共 ${checked} 個（只針對貼上那一行 PDB 中有對應 position 的情況）。<br/>`;
      if (mismatches.length === 0) {
        html += `<span style="color:green;">所有輸出為 0 的 HP/HB 欄位，在貼上的原始資料中對應 position/type 的 bits 也都是 0（未發現不一致）。</span>`;
      } else {
        html += `<span style="color:red;">發現 ${mismatches.length} 個不一致的欄位，前幾個例子：</span><br/>`;
        mismatches.slice(0, 10).forEach(m => {
          html += `feature=${escapeHtml(m.feature)}，對應 IFP_name=${escapeHtml(m.ifpName)}，貼上的原始 bit=${m.bit}<br/>`;
        });
      }
      return html;
    }

    function escapeHtml(str) {
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }
  </script>
</body>
</html>
