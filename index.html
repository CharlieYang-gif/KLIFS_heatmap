<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Kinase IFP Heatmap Tool (KLIFS + Docking Compare, Simplified Workflow)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root{
      --bg:#f5f5f5;
      --panel:#ffffff;
      --text:#333;
      --muted:#666;
      --primary:#1f7ae0;
      --primary-dark:#155cb0;
      --border:#e6e6e6;
      --border-strong:#b8c7e6;
      --danger:#c0392b;
      --ok:#2e7d32;
      --pill-bg:#eef4ff;
      --shadow:0 2px 8px rgba(0,0,0,0.08);
    }
    body{ font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:0; padding:16px 24px; background:var(--bg); color:var(--text); }
    h1{ margin:0 0 12px 0; color:var(--primary); }
    h2{ margin:0 0 10px 0; }
    h3{ margin:12px 0 6px 0; }
    .panel{ background:var(--panel); border-radius:12px; padding:18px 20px; margin-bottom:16px; box-shadow:var(--shadow); border:1px solid #f0f0f0; }
    .muted{ color:var(--muted); font-size:13px; line-height:1.55; }
    .small{ font-size:12px; }
    .status{ font-weight:900; color:#b26a00; }
    .pill{ display:inline-block; padding:2px 10px; border-radius:999px; background:var(--pill-bg); color:var(--primary); font-weight:900; font-size:12px; border:1px solid #dbe7ff; }
    .danger{ color:var(--danger); font-weight:900; }
    .ok{ color:var(--ok); font-weight:900; }
    .flex-row{ display:flex; flex-wrap:wrap; gap:12px; align-items:flex-end; }
    .field{ min-width:260px; }
    label{ font-weight:800; display:block; margin-bottom:6px; }
    input[type="file"], input[type="text"], input[type="number"], select, button{
      border:1px solid #ccc; border-radius:10px; padding:10px; font-size:13px; background:#fff;
    }
    button{ background:var(--primary); color:#fff; border:none; font-weight:800; cursor:pointer; }
    button:hover{ background:var(--primary-dark); }
    button:disabled{ background:#ccc; cursor:not-allowed; }
    input:disabled, select:disabled{ background:#f1f1f1; cursor:not-allowed; }
    hr{ border:0; border-top:1px solid #eee; margin:14px 0; }

    .dual{ display:flex; gap:12px; flex-wrap:wrap; margin-top:10px; }
    .col{ flex:1; min-width:260px; }
    .midcol{ min-width:140px; display:flex; flex-direction:column; gap:10px; justify-content:center; }
    .selectbox{ width:100%; min-height:240px; }
    .box-note{ border:1px dashed #ddd; border-radius:10px; padding:10px; background:#fafafa; }
    .btn-secondary{
      background:#f3f6ff; color:#1f3e75; border:1px solid #cfe0ff;
    }
    .btn-secondary:hover{ background:#e7efff; }
    .btn-danger{
      background:#fff; color:#8a1f14; border:1px solid #f2c7c2;
    }
    .btn-danger:hover{ background:#fff2f1; }

    #klifsHeatmap, #dockHeatmap, #diffPlot, #mdsPlot, #confusionPlot{
      width:100%; min-height:520px; margin-top:10px; background:#fff; border:1px solid #eee; border-radius:12px;
    }
    #dockHeatmap{
      border:3px solid var(--border-strong);
      box-shadow:0 2px 10px rgba(31,122,224,0.12);
    }
    details{
      border:1px solid #eee; border-radius:10px; padding:10px 12px; background:#fafafa;
    }
    summary{
      cursor:pointer; font-weight:900; color:#334; outline:none;
    }
    .inline{
      display:inline-flex; gap:8px; align-items:center; flex-wrap:wrap;
    }
    .kpi{
      display:flex; flex-wrap:wrap; gap:10px; margin-top:10px;
    }
    .kpi .card{
      background:#fff;
      border:1px solid #eee;
      border-radius:12px;
      padding:10px 12px;
      min-width:180px;
    }
    .kpi .card .k{ font-size:12px; color:var(--muted); font-weight:800; }
    .kpi .card .v{ font-size:18px; font-weight:900; margin-top:2px; }
  </style>
</head>
<body>
  <h1>Kinase Interaction Heatmap Tool</h1>

  <!-- =======================
       Panel 1: Data Load
       ======================= -->
  <div class="panel">
    <h2>1) 資料載入</h2>
    <div class="muted">
      流程：<b>先</b>設定並更新 <b>KLIFS heatmap</b> → <b>再</b>按 Compare 產生 <b>Docking heatmap</b>（分開繪製且對齊）。<br/>
      Reset 只會重置操作狀態與圖表，不會清掉已匯入的檔案。
    </div>

    <div class="flex-row" style="margin-top:10px;">
      <div class="field">
        <label>(A) 上傳 KLIFS_export.csv（NAME / FAMILY / GROUPS）</label>
        <input type="file" id="metaCsvInput" accept=".csv,.tsv,text/csv,text/tab-separated-values" />
      </div>
      <div class="field">
        <label>(B) 上傳 KLIFS IFP xlsx</label>
        <input type="file" id="klifsIfpInput" accept=".xlsx" disabled />
      </div>
      <div class="field">
        <label>(C) 上傳 alignment xlsx（含 kinase / structure_ID / pdb(可選) / 1..85）</label>
        <input type="file" id="alignXlsxInput" accept=".xlsx" disabled />
      </div>
      <div class="field">
        <label>(D) 上傳 Docking pose xlsx（原始 Glide pose table）</label>
        <input type="file" id="dockXlsxInput" accept=".xlsx" disabled />
      </div>

      <div class="field" style="min-width:360px;">
        <label>Docking kinase 名稱（Compare 用，例：CLK4）</label>
        <input type="text" id="dockKinaseInput" placeholder="例如：CLK4" disabled />
      </div>

      <div class="field" style="min-width:340px;">
        <label>狀態</label>
        <div class="status" id="statusText">初始化：請先上傳 KLIFS_export.csv</div>
        <div class="muted small" id="loadInfo" style="margin-top:6px;"></div>
      </div>

      <div class="field" style="min-width:220px;">
        <label>快速操作</label>
        <div class="inline">
          <button class="btn-danger" id="resetBtn" disabled>Reset（重置設定）</button>
        </div>
      </div>
    </div>

    <details style="margin-top:12px;">
      <summary>Advanced（很少需要調整）</summary>
      <div class="flex-row" style="margin-top:10px;">
        <div class="field" style="min-width:320px;">
          <label>Feature x 軸顯示模式</label>
          <select id="featureLabelMode" disabled>
            <option value="auto">Auto（Compare 前：KLIFS 1–85；Compare 後：顯示 residue）</option>
            <option value="klifs">強制 KLIFS 1–85（例如 12-HB）</option>
            <option value="residue">強制 residue number（例如 167-HB；需要 alignment + docking kinase）</option>
          </select>
          <div class="muted small">Compare 後會鎖定成 residue label，以確保對齊 Docking heatmap。</div>
        </div>

        <div class="field" style="min-width:360px;">
          <label>Docking 蛋白 PDB（可選；優先於 docking table 自動抓到的 PDB）</label>
          <input type="text" id="dockPdbInput" placeholder="例如：3pix（不填則自動從 docking pose table 的 pdb 欄推定）" disabled />
          <div class="muted small">用來在「同一 kinase 多個 structure_ID」時挑最匹配的 alignment row，避免 residue mapping 錯位。</div>
        </div>
      </div>
    </details>
  </div>

  <!-- =======================
       Panel 2: KLIFS Heatmap Setup
       ======================= -->
  <div class="panel">
    <h2>2) KLIFS Heatmap 設定（先做這一步）</h2>
    <div class="box-note muted">
      操作方式：先選擇 viewMode（kinase / family / group）→ 用左右清單選取要顯示的項目（可留空代表全顯示）→ 按「更新 KLIFS Heatmap」。
    </div>

    <div class="flex-row" style="margin-top:10px;">
      <div class="field" style="min-width:300px;">
        <label>Heatmap 顯示層級（viewMode）</label>
        <select id="viewModeSelect" disabled>
          <option value="kinase">Kinase</option>
          <option value="family">Family</option>
          <option value="group">Group</option>
        </select>
      </div>

      <div class="field">
        <button id="runKlifsHeatmapBtn" disabled>更新 KLIFS Heatmap</button>
      </div>

      <div class="field">
        <button id="compareBtn" disabled>Compare（Docking vs KLIFS）</button>
      </div>

      <div class="field" style="min-width:520px;">
        <div class="muted" id="summaryInfo"></div>
      </div>

      <div class="field" style="min-width:340px;">
        <label>匯出</label>
        <div class="inline">
          <button class="btn-secondary" id="exportExcelBtn" disabled>匯出 Excel（heatmap + metrics）</button>
          <button class="btn-secondary" id="exportAllPngBtn" disabled>匯出所有圖（PNG）</button>
        </div>
        <div class="muted small">Compare 後才會包含 Docking/差異分析/Confusion matrix。</div>
      </div>
    </div>

    <div class="dual">
      <div class="col">
        <label id="availableLabel">待選清單</label>
        <select id="availableList" class="selectbox" multiple disabled></select>
        <div class="muted small">可雙擊移到右側。</div>
      </div>

      <div class="midcol">
        <button id="addBtn" disabled>加入 ➔</button>
        <button id="removeBtn" disabled>⬅ 移除</button>
        <button class="btn-secondary" id="clearSelectedBtn" disabled>清空已選（= 全顯示）</button>
      </div>

      <div class="col">
        <label id="selectedLabel">已選清單（Y 軸）</label>
        <select id="selectedList" class="selectbox" multiple disabled></select>
        <div class="muted small">可雙擊移回左側。</div>
      </div>
    </div>
  </div>

  <!-- =======================
       Panel 3: Results
       ======================= -->
  <div class="panel">
    <h2>3) 結果</h2>

    <h3>KLIFS Heatmap</h3>
    <div class="muted small">
      Compare 前：預設以 KLIFS 1–85 為 x 軸。Compare 後：KLIFS heatmap 會切到 residue label 並與 Docking heatmap 對齊。<br/>
      你之後改 KLIFS 設定再按「更新 KLIFS Heatmap」時，Docking heatmap 不會消失；統計會以「目前 heatmap 選取範圍」重算。
    </div>
    <div id="klifsHeatmap"></div>

    <div class="inline" style="margin-top:10px;">
      <button class="btn-secondary" id="exportKlifsPngBtn" disabled>匯出 KLIFS Heatmap PNG</button>
    </div>

    <hr/>

    <h3>Docking Heatmap（由 Compare 產生；會以粗框標示）</h3>
    <div class="muted small">
      只在你按 Compare 後出現。若同一 kinase 在 alignment 有多個 structure_ID，會用「Docking PDB（手填優先，其次 docking table 的 pdb 欄）」挑最匹配的 alignment row。
    </div>
    <div id="dockHeatmap"></div>

    <div class="inline" style="margin-top:10px;">
      <button class="btn-secondary" id="exportDockPngBtn" disabled>匯出 Docking Heatmap PNG</button>
    </div>

    <details style="margin-top:12px;">
      <summary>Docking 差異分析（可選）</summary>

      <div class="muted small" style="margin-top:10px;">
        說明：此區塊的 KLIFS 參考集合一律以「<b>目前 heatmap 選取的 kinase/family/group</b>」為準（不再被 docking kinase 的 family/group 綁死）。<br/>
        Confusion matrix 定義：<b>Docking freq ≥ 50%</b> 為 True Positive 標準；<b>KLIFS freq ≥ 閾值</b> 為測試判定 positive（閾值輸入 0–1）。
      </div>

      <div class="flex-row" style="margin-top:10px;">
        <div class="field" style="min-width:260px;">
          <label>KLIFS positive 閾值（0–1）</label>
          <input type="number" id="klifsThreshInput" min="0" max="1" step="0.01" value="0.50" disabled />
          <div class="muted small">例如 0.50 代表 KLIFS freq ≥ 50% 視為 positive。</div>
        </div>

        <div class="field">
          <button id="recalcAnalysisBtn" disabled>重算差異分析 / Confusion</button>
        </div>

        <div class="field">
          <button class="btn-secondary" id="exportDiffPngBtn" disabled>匯出 Diff PNG</button>
        </div>
        <div class="field">
          <button class="btn-secondary" id="exportMdsPngBtn" disabled>匯出 MDS PNG</button>
        </div>
        <div class="field">
          <button class="btn-secondary" id="exportConfPngBtn" disabled>匯出 Confusion PNG</button>
        </div>
      </div>

      <div id="diffPlot"></div>
      <div style="height:10px;"></div>
      <div id="mdsPlot"></div>

      <hr/>

      <h3 style="margin-top:0;">Confusion matrix（以 feature 為單位）</h3>
      <div id="confusionPlot"></div>

      <div class="kpi" id="metricsCards"></div>
      <div class="muted small" id="metricsNote" style="margin-top:8px;"></div>
    </details>
  </div>

<script>
/* ===========================
   0) Global + DOM
   =========================== */
const statusText = document.getElementById("statusText");
const loadInfo   = document.getElementById("loadInfo");
const summaryInfo= document.getElementById("summaryInfo");

const metaCsvInput   = document.getElementById("metaCsvInput");
const klifsIfpInput  = document.getElementById("klifsIfpInput");
const alignXlsxInput = document.getElementById("alignXlsxInput");
const dockXlsxInput  = document.getElementById("dockXlsxInput");

const dockKinaseInput= document.getElementById("dockKinaseInput");
const dockPdbInput   = document.getElementById("dockPdbInput");

const viewModeSelect = document.getElementById("viewModeSelect");
const featureLabelModeSelect = document.getElementById("featureLabelMode");

const runKlifsHeatmapBtn = document.getElementById("runKlifsHeatmapBtn");
const compareBtn = document.getElementById("compareBtn");
const resetBtn   = document.getElementById("resetBtn");

const availableList = document.getElementById("availableList");
const selectedList  = document.getElementById("selectedList");
const addBtn = document.getElementById("addBtn");
const removeBtn = document.getElementById("removeBtn");
const clearSelectedBtn = document.getElementById("clearSelectedBtn");

const availableLabel = document.getElementById("availableLabel");
const selectedLabel  = document.getElementById("selectedLabel");

// export buttons
const exportExcelBtn = document.getElementById("exportExcelBtn");
const exportAllPngBtn = document.getElementById("exportAllPngBtn");
const exportKlifsPngBtn = document.getElementById("exportKlifsPngBtn");
const exportDockPngBtn  = document.getElementById("exportDockPngBtn");
const exportDiffPngBtn  = document.getElementById("exportDiffPngBtn");
const exportMdsPngBtn   = document.getElementById("exportMdsPngBtn");
const exportConfPngBtn  = document.getElementById("exportConfPngBtn");

// analysis UI
const klifsThreshInput = document.getElementById("klifsThreshInput");
const recalcAnalysisBtn = document.getElementById("recalcAnalysisBtn");
const metricsCards = document.getElementById("metricsCards");
const metricsNote = document.getElementById("metricsNote");

const kinaseKeyName = "kinase";

// load flags
let metaLoaded=false, klifsLoaded=false, alignLoaded=false, dockLoaded=false;

// meta
let metaRowsRaw=[];
let metaNormToRow = new Map();
let familyList=[], groupList=[];

// KLIFS IFP
let klifsRaw2D=null;
let klifsFeatureKeys=[];        // "1-HP","1-HB"... "85-HB"
let klifsKinaseFreqRows=[];     // per-kinase freq %
let klifsStructBinaryRows=[];   // per-structure 0/1
let allKinaseNames=[];

// alignment
let alignmentMapById = new Map();          // structure_ID -> {pos->residueNumber}
let alignmentKinaseToStructIds = new Map();// normKinase -> [structure_ID,...]
let alignmentPdbById = new Map();          // structure_ID -> pdb (optional)

// docking
let dockRaw2D=null;
let dockBinaryRows=[];
let dockFreqRow=null;
let lastDockAlignmentSid="";               // the structure_ID used for mapping

// workflow states
let viewMode="kinase";
let featureLabelMode="auto";
let lastKlifsRows=[];                      // last KLIFS rows shown (heatmap rows)
let lastKlifsTitle="KLIFS Interaction Frequency Heatmap (%)";
let residueModeActive=false;               // after Compare -> true
let residueFeatureMap = new Map();         // feature -> display label (residue-kind)

// cache for analysis
let lastCompareKlifsStruct = [];           // KLIFS binary rows used in compare scope (selection-based)
let lastCompareKlifsFreq = null;           // freq row computed from those structures
let lastMetrics = null;                    // confusion + metrics
let lastMds = null;                        // perma etc.

function setStatus(msg){ statusText.textContent = msg; }
function safeTrim(v){ return (v==null) ? "" : String(v).trim(); }

/* ===========================
   1) IO utils
   =========================== */
function readXlsxArrayBuffer(buffer){
  const data = new Uint8Array(buffer);
  const wb = XLSX.read(data, { type:"array" });
  const ws = wb.Sheets[wb.SheetNames[0]];
  return XLSX.utils.sheet_to_json(ws, { header:1, raw:true, defval:null });
}
function parseCsvLoose(text){
  const lines = text.split(/\r?\n/).filter(l => l.trim() !== "");
  if (lines.length < 2) return { header:[], rows:[] };

  const split = (line) => {
    const c = line.split(",");
    const t = line.split("\t");
    const parts = (t.length > c.length) ? t : c;
    return parts.map(x => x.trim());
  };

  const header = split(lines[0]);
  const rows = [];
  for (let i=1; i<lines.length; i++) rows.push(split(lines[i]));
  return { header, rows };
}
function findCol(header, candidates){
  const lower = header.map(h => safeTrim(h).toLowerCase());
  for (const cand of candidates){
    const idx = lower.indexOf(String(cand).toLowerCase());
    if (idx >= 0) return idx;
  }
  return -1;
}
function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 500);
}

/* ===========================
   2) Name normalization
   =========================== */
function normalizeNameBasic(s){
  const up = safeTrim(s).toUpperCase();
  const noParen = up.replace(/\(.*?\)/g, " ");
  return noParen.replace(/[^A-Z0-9]+/g, "");
}
function normalizeNameKeepParenAliases(s){
  const raw = safeTrim(s);
  const m = raw.match(/^(.*?)\((.*?)\)\s*$/);
  if (!m) return { primary: normalizeNameBasic(raw), alias:"" };
  return { primary: normalizeNameBasic(m[1]), alias: normalizeNameBasic(m[2]) };
}
function lookupMetaForKinase(kinaseName){
  const nk = normalizeNameBasic(kinaseName);
  let row = metaNormToRow.get(nk);
  if (row) return { matched:true, FAMILY: row.FAMILY||"", GROUPS: row.GROUPS||"" };

  const parts = normalizeNameKeepParenAliases(kinaseName);
  row = metaNormToRow.get(parts.primary) || metaNormToRow.get(parts.alias);
  if (row) return { matched:true, FAMILY: row.FAMILY||"", GROUPS: row.GROUPS||"" };

  return { matched:false, FAMILY:"", GROUPS:"" };
}

/* ===========================
   3) UI locking + workflow
   =========================== */
function refreshUiLocks(){
  const coreReady = metaLoaded && klifsLoaded;

  klifsIfpInput.disabled   = !metaLoaded;
  alignXlsxInput.disabled  = !(metaLoaded && klifsLoaded);
  dockXlsxInput.disabled   = !(metaLoaded && klifsLoaded && alignLoaded);

  viewModeSelect.disabled  = !coreReady;
  runKlifsHeatmapBtn.disabled = !coreReady;

  // list UI
  const listReady = coreReady;
  availableList.disabled = !listReady;
  selectedList.disabled  = !listReady;
  addBtn.disabled        = !listReady;
  removeBtn.disabled     = !listReady;
  clearSelectedBtn.disabled = !listReady;

  // compare requires: core + alignment + docking + docking kinase input
  dockKinaseInput.disabled = !(metaLoaded && klifsLoaded && alignLoaded && dockLoaded);
  dockPdbInput.disabled    = !(metaLoaded && klifsLoaded && alignLoaded && dockLoaded);
  featureLabelModeSelect.disabled = !coreReady;

  const compareReady = coreReady && alignLoaded && dockLoaded && safeTrim(dockKinaseInput.value)!=="";
  compareBtn.disabled = !compareReady;

  resetBtn.disabled = !coreReady;

  // analysis tools enable after compare
  const analysisReady = residueModeActive && !!dockFreqRow && lastCompareKlifsFreq;
  klifsThreshInput.disabled = !analysisReady;
  recalcAnalysisBtn.disabled = !analysisReady;
  exportDiffPngBtn.disabled = !analysisReady;
  exportMdsPngBtn.disabled = !analysisReady;
  exportConfPngBtn.disabled = !analysisReady;

  exportExcelBtn.disabled = !coreReady; // excel can export KLIFS even pre-compare
  exportAllPngBtn.disabled = !coreReady;
  exportKlifsPngBtn.disabled = !coreReady;
  exportDockPngBtn.disabled = !(residueModeActive && !!dockFreqRow);

  loadInfo.innerHTML =
    `Meta: <span class="pill">${metaLoaded?"OK":"Missing"}</span> ` +
    `KLIFS IFP: <span class="pill">${klifsLoaded?"OK":"Missing"}</span> ` +
    `Alignment: <span class="pill">${alignLoaded?"OK":"Missing (Compare needs it)"}</span> ` +
    `Docking: <span class="pill">${dockLoaded?"OK":"Optional"}</span>`;
}

/* ===========================
   4) Meta CSV
   =========================== */
function parseMetaCsv(text){
  const { header, rows } = parseCsvLoose(text);
  const idxName   = findCol(header, ["name","NAME"]);
  const idxFamily = findCol(header, ["family","FAMILY"]);
  const idxGroup  = findCol(header, ["groups","group","GROUPS","GROUP"]);

  if (idxName<0 || idxFamily<0 || idxGroup<0){
    throw new Error("KLIFS_export.csv 需要包含欄位：NAME / FAMILY / GROUPS（大小寫可不同）");
  }

  metaRowsRaw = [];
  metaNormToRow = new Map();
  const famSet = new Set();
  const grpSet = new Set();

  for (const r of rows){
    if (!r || r.length <= Math.max(idxName, idxFamily, idxGroup)) continue;
    const NAME = safeTrim(r[idxName]);
    if (!NAME) continue;
    const FAMILY = safeTrim(r[idxFamily]);
    const GROUPS = safeTrim(r[idxGroup]);
    const rowObj = { NAME, FAMILY, GROUPS };
    metaRowsRaw.push(rowObj);

    const parts = normalizeNameKeepParenAliases(NAME);
    if (parts.primary) metaNormToRow.set(parts.primary, rowObj);
    if (parts.alias) metaNormToRow.set(parts.alias, rowObj);

    if (FAMILY) famSet.add(FAMILY);
    if (GROUPS) grpSet.add(GROUPS);
  }

  familyList = Array.from(famSet).sort((a,b)=>String(a).localeCompare(String(b)));
  groupList  = Array.from(grpSet).sort((a,b)=>String(a).localeCompare(String(b)));
}

metaCsvInput.addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;
  try{
    setStatus("載入 KLIFS_export.csv 中...");
    const text = await file.text();
    parseMetaCsv(text);
    metaLoaded = true;
    setStatus("KLIFS_export.csv 載入完成（請上傳 KLIFS IFP xlsx）");
  }catch(err){
    console.error(err);
    metaLoaded=false;
    setStatus("KLIFS_export.csv 載入失敗：" + err.message);
  }finally{
    refreshUiLocks();
    rebuildAvailableSelectedLists(true);
  }
});

/* ===========================
   5) KLIFS IFP load -> HP/HB collapse
   =========================== */
const positionRowIndex = 1;
const ifpTypeRowIndex  = 2;
const metaRowsCount    = 5;

function detectIfpColumnsFromHeader(data2D){
  const header = data2D?.[0] || [];
  const idx=[];
  for (let c=0;c<header.length;c++){
    const name = safeTrim(header[c]);
    if (/^IFP_/i.test(name)) idx.push(c);
  }
  idx.sort((a,b)=>a-b);
  return idx;
}
function collapseKlifsToHpHb(data2D, nMetaCols, ifpCols){
  const headerRow = data2D[0] || [];
  const positionRow = data2D[positionRowIndex] || [];
  const ifpTypeRow = data2D[ifpTypeRowIndex] || [];

  const hpTypes = new Set([1,2,3]);
  const hbTypes = new Set([4,5,6,7]);

  const posToHpCols = {};
  const posToHbCols = {};

  for (const colIdx of ifpCols){
    const pos = positionRow[colIdx];
    const t = ifpTypeRow[colIdx];
    if (pos==null || t==null || pos==="" || t==="") continue;
    const posInt = parseInt(pos,10);
    const tInt = parseInt(t,10);
    if (!Number.isFinite(posInt) || !Number.isFinite(tInt)) continue;
    if (!posToHpCols[posInt]) posToHpCols[posInt]=[];
    if (!posToHbCols[posInt]) posToHbCols[posInt]=[];
    if (hpTypes.has(tInt)) posToHpCols[posInt].push(colIdx);
    else if (hbTypes.has(tInt)) posToHbCols[posInt].push(colIdx);
  }

  const allPos0 = Array.from(new Set([
    ...Object.keys(posToHpCols).map(Number),
    ...Object.keys(posToHbCols).map(Number),
  ])).sort((a,b)=>a-b);

  const metaKeys=[];
  for (let c=0;c<nMetaCols;c++){
    const name = safeTrim(headerRow[c]);
    if (!name) continue;
    metaKeys.push({idx:c, name});
  }

  const structRows=[];
  for (let r=metaRowsCount; r<data2D.length; r++){
    const row = data2D[r];
    if (!row || row.every(v=>v==null || String(v).trim()==="")) continue;

    const obj={};
    for (const mk of metaKeys) obj[mk.name] = row[mk.idx];

    for (const pos0 of allPos0){
      const hpCols = posToHpCols[pos0] || [];
      const hbCols = posToHbCols[pos0] || [];
      let hp=0, hb=0;
      for (const idx of hpCols){ const v=Number(row[idx]); if (Number.isFinite(v) && v>0){ hp=1; break; } }
      for (const idx of hbCols){ const v=Number(row[idx]); if (Number.isFinite(v) && v>0){ hb=1; break; } }
      const p = pos0 + 1;
      obj[`${p}-HP`] = hp;
      obj[`${p}-HB`] = hb;
    }
    structRows.push(obj);
  }

  const featureKeys=[];
  for (const pos0 of allPos0){
    const p=pos0+1;
    featureKeys.push(`${p}-HP`, `${p}-HB`);
  }
  return { structRows, featureKeys };
}
function computeKinaseFreqAndStructBinary(structRows, featureKeys, kinaseColName, structureColName){
  const groups = new Map();
  const structBinary = [];

  for (const r of structRows){
    const k = r[kinaseColName];
    if (!k) continue;
    if (!groups.has(k)) groups.set(k, []);
    groups.get(k).push(r);

    const bin = {};
    bin[kinaseKeyName] = k;
    bin.structure_ID = r[structureColName];
    for (const f of featureKeys) bin[f] = Number(r[f]) ? 1 : 0;
    structBinary.push(bin);
  }

  const kinases = Array.from(groups.keys()).sort((a,b)=>String(a).localeCompare(String(b)));
  const freqRows = [];

  for (const k of kinases){
    const rows = groups.get(k);
    const out = {};
    out[kinaseKeyName]=k;
    out.__n = rows.length;
    out.__label = `${k} (n=${rows.length})`;
    for (const f of featureKeys){
      let sum=0;
      for (const r of rows) sum += Number(r[f]) ? 1 : 0;
      out[f] = rows.length ? (sum/rows.length)*100 : 0;
    }
    freqRows.push(out);
  }

  return { kinases, freqRows, structBinary };
}

klifsIfpInput.addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;
  try{
    setStatus("載入 KLIFS IFP xlsx 中...");
    const buffer = await file.arrayBuffer();
    klifsRaw2D = readXlsxArrayBuffer(buffer);

    const header = (klifsRaw2D[0] || []).map(safeTrim);
    const ifpCols = detectIfpColumnsFromHeader(klifsRaw2D);
    if (!ifpCols.length) throw new Error("找不到 IFP_ 欄位（header 需有 IFP_0, IFP_1...）");

    const kinaseIdx = findCol(header, ["kinase"]);
    const structureIdx = findCol(header, ["structure_id","structure id","structureid"]);
    if (kinaseIdx<0) throw new Error("KLIFS IFP 需包含 'kinase' 欄位");
    if (structureIdx<0) throw new Error("KLIFS IFP 需包含 'structure_ID' 欄位（連結 alignment）");

    // nMetaCols：以第一個 IFP_ 欄位起點為準（避免誤判 meta 欄位）
    const firstIfpCol = Math.min(...ifpCols);
    const nMetaCols = Math.max(firstIfpCol, 4);

    const build = collapseKlifsToHpHb(klifsRaw2D, nMetaCols, ifpCols);
    klifsFeatureKeys = build.featureKeys.slice();

    const structRows = build.structRows.map(r=>{
      const out = { ...r };
      out[kinaseKeyName] = r[header[kinaseIdx]];
      out.structure_ID = r[header[structureIdx]];
      return out;
    });

    const calc = computeKinaseFreqAndStructBinary(structRows, klifsFeatureKeys, kinaseKeyName, "structure_ID");
    allKinaseNames = calc.kinases.slice();
    klifsKinaseFreqRows = calc.freqRows.slice();
    klifsStructBinaryRows = calc.structBinary.slice();

    klifsLoaded = true;
    setStatus("KLIFS IFP 載入完成（請上傳 alignment；若要 Compare 再上傳 docking）");

  }catch(err){
    console.error(err);
    klifsLoaded=false;
    setStatus("KLIFS IFP 載入失敗：" + err.message);
  }finally{
    refreshUiLocks();
    rebuildAvailableSelectedLists(true);
  }
});

/* ===========================
   6) Alignment load
   =========================== */
function parseAlignmentXlsx(data2D){
  if (!data2D || data2D.length < 2) throw new Error("alignment xlsx 內容太少");
  const header = (data2D[0] || []).map(safeTrim);

  const idxKinase = findCol(header, ["kinase"]);
  const idxPdb    = findCol(header, ["pdb"]); // optional
  const idxStruct = findCol(header, ["structure_id","structure id","structureid","structure_ID","structureId"]);

  if (idxStruct < 0) throw new Error("alignment xlsx 需包含 structure_ID 欄位");
  if (idxKinase < 0) throw new Error("alignment xlsx 需包含 kinase 欄位");

  const posColIdx = new Map();
  for (let c = 0; c < header.length; c++) {
    const p = parseInt(header[c], 10);
    if (Number.isFinite(p) && p >= 1 && p <= 85) posColIdx.set(p, c);
  }
  if (posColIdx.size < 10) throw new Error("alignment header 必須包含 1..85 欄位（首行）");

  alignmentMapById = new Map();
  alignmentKinaseToStructIds = new Map();
  alignmentPdbById = new Map();

  let n=0;
  for (let r = 1; r < data2D.length; r++) {
    const row = data2D[r];
    if (!row || row.every(v => v == null || String(v).trim() === "")) continue;

    const kinase = safeTrim(row[idxKinase]);
    const structId = safeTrim(row[idxStruct]);
    if (!kinase || !structId) continue;

    const map = {};
    for (let p=1; p<=85; p++){
      const c = posColIdx.get(p);
      const valStr = (c == null) ? "" : safeTrim(row[c]);
      if (!valStr || valStr === "_" || valStr === "-") { map[p] = null; continue; }
      const num = parseInt(valStr, 10);
      map[p] = Number.isFinite(num) ? num : null;
    }

    alignmentMapById.set(structId, map);
    n++;

    const pdb = (idxPdb>=0) ? safeTrim(row[idxPdb]) : "";
    if (pdb) alignmentPdbById.set(structId, pdb);

    const nk = normalizeNameBasic(kinase);
    if (!alignmentKinaseToStructIds.has(nk)) alignmentKinaseToStructIds.set(nk, []);
    alignmentKinaseToStructIds.get(nk).push(structId);
  }

  for (const [k, ids] of alignmentKinaseToStructIds.entries()){
    ids.sort((a,b)=>String(a).localeCompare(String(b)));
  }

  return n;
}

alignXlsxInput.addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;
  try{
    setStatus("載入 alignment xlsx 中...");
    const buffer = await file.arrayBuffer();
    const data2D = readXlsxArrayBuffer(buffer);
    const n = parseAlignmentXlsx(data2D);
    alignLoaded = true;
    setStatus(`alignment 載入完成（rows=${n}）→ 可上傳 Docking pose xlsx`);
  }catch(err){
    console.error(err);
    alignLoaded=false;
    setStatus("alignment 載入失敗：" + err.message);
  }finally{
    refreshUiLocks();
  }
});

/* ===========================
   7) Docking load
   =========================== */
dockXlsxInput.addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;
  try{
    setStatus("載入 Docking pose xlsx 中...");
    const buffer = await file.arrayBuffer();
    dockRaw2D = readXlsxArrayBuffer(buffer);
    dockLoaded = true;
    setStatus("Docking pose 載入完成（輸入 docking kinase 後即可 Compare）");
  }catch(err){
    console.error(err);
    dockLoaded=false;
    setStatus("Docking pose 載入失敗：" + err.message);
  }finally{
    refreshUiLocks();
  }
});

dockKinaseInput.addEventListener("input", refreshUiLocks);

/* ===========================
   8) List UI
   =========================== */
function getSelectedValues(){
  return Array.from(selectedList.options).map(o=>o.value);
}
function moveSelected(fromSel, toSel){
  const opts = Array.from(fromSel.selectedOptions);
  for (const opt of opts){
    const exists = Array.from(toSel.options).some(o=>o.value===opt.value);
    if (!exists){
      const n=document.createElement("option");
      n.value=opt.value; n.textContent=opt.textContent;
      toSel.appendChild(n);
    }
    fromSel.removeChild(opt);
  }
}
addBtn.addEventListener("click", ()=>moveSelected(availableList, selectedList));
removeBtn.addEventListener("click", ()=>moveSelected(selectedList, availableList));
availableList.addEventListener("dblclick", ()=>moveSelected(availableList, selectedList));
selectedList.addEventListener("dblclick", ()=>moveSelected(selectedList, availableList));
clearSelectedBtn.addEventListener("click", ()=>{
  const opts = Array.from(selectedList.options);
  for (const opt of opts){
    const n=document.createElement("option");
    n.value=opt.value; n.textContent=opt.textContent;
    availableList.appendChild(n);
    selectedList.removeChild(opt);
  }
  const arr = Array.from(availableList.options).map(o=>o.value).sort((a,b)=>String(a).localeCompare(String(b)));
  availableList.innerHTML="";
  arr.forEach(v=>{
    const o=document.createElement("option");
    o.value=v; o.textContent=v;
    availableList.appendChild(o);
  });
});

function rebuildAvailableSelectedLists(resetSelected=false){
  if (!(metaLoaded && klifsLoaded)){
    availableList.innerHTML="";
    selectedList.innerHTML="";
    return;
  }
  viewMode = viewModeSelect.value || "kinase";

  let items=[];
  if (viewMode==="kinase") items = allKinaseNames.slice();
  else if (viewMode==="family") items = familyList.slice();
  else items = groupList.slice();

  items.sort((a,b)=>String(a).localeCompare(String(b)));

  if (resetSelected){
    selectedList.innerHTML="";
  }

  const selectedSet = new Set(getSelectedValues());
  availableList.innerHTML="";

  for (const it of items){
    if (selectedSet.has(it)) continue;
    const o=document.createElement("option");
    o.value=it; o.textContent=it;
    availableList.appendChild(o);
  }

  if (viewMode==="kinase"){
    availableLabel.textContent = "待選 kinase";
    selectedLabel.textContent  = "已選 kinase（Y 軸；留空=全顯示）";
  }else if (viewMode==="family"){
    availableLabel.textContent = "待選 family";
    selectedLabel.textContent  = "已選 family（Y 軸；留空=全顯示）";
  }else{
    availableLabel.textContent = "待選 group";
    selectedLabel.textContent  = "已選 group（Y 軸；留空=全顯示）";
  }
}

viewModeSelect.addEventListener("change", ()=>{
  rebuildAvailableSelectedLists(true);
});

/* ===========================
   9) KLIFS rows generation by viewMode + selected list
   =========================== */
function aggregateFreqRowsByScope(scope, value){
  const key = scope==="family" ? "FAMILY" : "GROUPS";
  const rows = klifsKinaseFreqRows.filter(r=>{
    const meta = lookupMetaForKinase(r[kinaseKeyName]);
    return meta[key] === value;
  });

  const out={};
  out[kinaseKeyName]=value;
  const nKinase = rows.length;
  const nStruct = rows.reduce((acc,r)=>acc+(Number(r.__n)||0),0);
  out.__n = nStruct;
  out.__label = `${value} (nKinase=${nKinase}, nStruct=${nStruct})`;

  for (const f of klifsFeatureKeys){
    let sum=0, count=0;
    for (const r of rows){
      const v=Number(r[f]);
      if (Number.isFinite(v)){ sum+=v; count++; }
    }
    out[f] = count ? (sum/count) : 0;
  }
  return out;
}

function getKlifsHeatmapRowsByCurrentSelection(){
  viewMode = viewModeSelect.value || "kinase";
  const picked = getSelectedValues(); // empty => all

  if (viewMode==="kinase"){
    let base = klifsKinaseFreqRows.slice();
    if (picked.length){
      const set = new Set(picked);
      base = base.filter(r=>set.has(r[kinaseKeyName]));
    }
    return base;
  }

  if (viewMode==="family"){
    const fams = picked.length ? picked : familyList.slice();
    const rows = fams.map(f => aggregateFreqRowsByScope("family", f));
    rows.sort((a,b)=>String(a[kinaseKeyName]).localeCompare(String(b[kinaseKeyName])));
    return rows;
  }

  const grps = picked.length ? picked : groupList.slice();
  const rows = grps.map(g => aggregateFreqRowsByScope("group", g));
  rows.sort((a,b)=>String(a[kinaseKeyName]).localeCompare(String(b[kinaseKeyName])));
  return rows;
}

/* ===========================
   10) Residue mapping helpers
   =========================== */
function buildResidueMapsByStructureId(structureId){
  const rowMap = alignmentMapById.get(structureId);
  const resToKlifs = new Map();
  const klifsToRes = new Map();
  if (!rowMap) return { resToKlifs, klifsToRes };

  for (let p=1; p<=85; p++){
    const res = rowMap[p];
    if (res==null) continue;
    klifsToRes.set(p, res);
    if (!resToKlifs.has(res)) resToKlifs.set(res, p);
  }
  return { resToKlifs, klifsToRes };
}
function normalizePdb(pdb){
  return safeTrim(pdb).toLowerCase();
}
function autoPickAlignmentStructureIdForDockingKinase(dk, preferredPdb){
  const k = safeTrim(dk);
  if (!k) return "";

  const nk = normalizeNameBasic(k);
  const ids = alignmentKinaseToStructIds.get(nk) || [];
  if (!ids.length) return "";

  const pref = normalizePdb(preferredPdb);
  if (pref){
    const matched = ids.find(sid => normalizePdb(alignmentPdbById.get(sid) || "") === pref);
    if (matched && alignmentMapById.has(matched)) return matched;
  }

  for (const sid of ids){
    if (alignmentMapById.has(sid)) return sid;
  }
  return "";
}

/* ===========================
   11) Feature display map (KLIFS vs residue)
   =========================== */
function buildFeatureDisplayMapForKlifs(){
  featureLabelMode = featureLabelModeSelect.value || "auto";

  const map = new Map();
  for (const f of klifsFeatureKeys) map.set(f, f);

  if (residueModeActive && residueFeatureMap && residueFeatureMap.size){
    for (const f of klifsFeatureKeys){
      map.set(f, residueFeatureMap.get(f) || f);
    }
    return map;
  }

  const wantResidue =
    featureLabelMode==="residue" ||
    (featureLabelMode==="auto" && alignLoaded && safeTrim(dockKinaseInput.value)!=="");

  if (!wantResidue) return map;

  const dk = safeTrim(dockKinaseInput.value);
  const preferred = safeTrim(dockPdbInput.value);
  const sid = autoPickAlignmentStructureIdForDockingKinase(dk, preferred);
  if (!sid) return map;

  const { klifsToRes } = buildResidueMapsByStructureId(sid);
  if (!klifsToRes.size) return map;

  for (const f of klifsFeatureKeys){
    const m = String(f).match(/^(\d+)\-(HP|HB)$/i);
    if (!m) continue;
    const pos = parseInt(m[1],10);
    const kind = m[2].toUpperCase();
    const res = klifsToRes.get(pos);
    if (res) map.set(f, `${res}-${kind}`);
  }
  return map;
}

/* ===========================
   12) Plotly heatmap drawer (two-tone colorscale)
   =========================== */
function makeTwoToneColorscale(){
  const t = 0.5;
  return [
    [0.00, "#2a004f"],
    [0.18, "#3b1a75"],
    [0.35, "#4b3aa0"],
    [t - 1e-6, "#9fe8dd"],
    [t, "#fdae61"],
    [0.75, "#f46d43"],
    [1.00, "#d73027"]
  ];
}

function drawHeatmap(targetDivId, rows, featureDisplayMap, title){
  if (!rows.length){
    Plotly.purge(targetDivId);
    return;
  }

  const x = klifsFeatureKeys.map(f=>featureDisplayMap.get(f) || f);
  const y = rows.map(r=>r.__label ?? r[kinaseKeyName] ?? "row");
  const z = rows.map(r=>klifsFeatureKeys.map(f=>{
    const v=Number(r[f]);
    return Number.isFinite(v) ? v : 0;
  }));

  Plotly.newPlot(targetDivId, [{
    x,y,z,
    type:"heatmap",
    colorscale: makeTwoToneColorscale(),
    zmin:0,
    zmax:100,
    colorbar:{ title:"Frequency (%)" }
  }], {
    title,
    xaxis:{ title:"Features", tickangle:-90 },
    yaxis:{ title:"Rows" },
    margin:{ l:240, r:20, t:50, b:170 },
    height: Math.max(560, 26*rows.length + 240),
  }, { responsive:true });
}

/* ===========================
   13) Selection-based KLIFS scope for analysis (Step 1–4)
   =========================== */
function getKlifsStructBinaryFromCurrentSelection(){
  const vm = viewModeSelect.value || "kinase";
  const picked = getSelectedValues(); // empty => all

  if (vm === "kinase"){
    if (!picked.length) return klifsStructBinaryRows.slice();
    const set = new Set(picked.map(safeTrim));
    return klifsStructBinaryRows.filter(r => set.has(safeTrim(r[kinaseKeyName])));
  }

  if (vm === "family"){
    const famSet = picked.length ? new Set(picked) : new Set(familyList);
    return klifsStructBinaryRows.filter(r => {
      const meta = lookupMetaForKinase(r[kinaseKeyName]);
      return famSet.has(meta.FAMILY);
    });
  }

  // group
  const grpSet = picked.length ? new Set(picked) : new Set(groupList);
  return klifsStructBinaryRows.filter(r => {
    const meta = lookupMetaForKinase(r[kinaseKeyName]);
    return grpSet.has(meta.GROUPS);
  });
}

function computeFreqFromBinaryRows(binaryRows){
  const out = { __n: binaryRows.length, __label: `KLIFS(scope n=${binaryRows.length})` };
  for (const f of klifsFeatureKeys){
    let sum = 0;
    for (const r of binaryRows) sum += Number(r[f]) ? 1 : 0;
    out[f] = binaryRows.length ? (sum / binaryRows.length) * 100 : 0;
  }
  return out;
}

/* ===========================
   14) KLIFS update button
   =========================== */
runKlifsHeatmapBtn.addEventListener("click", ()=>{
  try{
    if (!(metaLoaded && klifsLoaded)) return;

    const rows = getKlifsHeatmapRowsByCurrentSelection();
    lastKlifsRows = rows.slice();
    const fmap = buildFeatureDisplayMapForKlifs();

    drawHeatmap("klifsHeatmap", rows, fmap, lastKlifsTitle);

    // 若已 Compare 過，則以「目前 selection」重算統計（Step 1–4）
    recomputeCompareStatsIfAvailable();

    const picked = getSelectedValues();
    const pickedText = picked.length ? `${picked.length} selected` : "ALL";
    const xMode = residueModeActive ? "residue (locked by Compare)" : (featureLabelModeSelect.value || "auto");
    summaryInfo.innerHTML =
      `ViewMode：<span class="pill">${viewModeSelect.value}</span>　` +
      `Rows：<span class="pill">${rows.length}</span>　` +
      `Picked：<span class="pill">${pickedText}</span>　` +
      `X-label：<span class="pill">${xMode}</span>`;

  }catch(err){
    console.error(err);
    alert("更新 KLIFS heatmap 失敗：" + err.message);
  }finally{
    refreshUiLocks();
  }
});

/* ===========================
   15) Docking processing
   =========================== */
const DOCK_KEYS = ["Pi-Hydrophobic","AlkylHydrophobic","MixedPiAlkylHydrophobic","HydrogenBond"];

function parseDockingInteractionColumn(colName){
  const s = String(colName||"");
  let kind=null;
  if (s.includes("HydrogenBond")) kind="HB";
  else if (s.includes("Pi-Hydrophobic") || s.includes("AlkylHydrophobic") || s.includes("MixedPiAlkylHydrophobic")) kind="HP";
  else return null;

  const m = s.match(/([A-Z]{3})(\d{1,5})/);
  if (!m) return null;
  const resNum = parseInt(m[2],10);
  if (!Number.isFinite(resNum)) return null;
  return { residueNumber: resNum, kind };
}

function inferDockingPdbFromDockTable(data2D){
  const header = (data2D[0] || []).map(safeTrim);
  const pdbIdx = findCol(header, ["pdb"]);
  if (pdbIdx < 0) return "";

  const counts = new Map();
  for (let r=1; r<data2D.length; r++){
    const row = data2D[r];
    if (!row) continue;
    const v = safeTrim(row[pdbIdx]);
    if (!v) continue;
    const key = normalizePdb(v);
    counts.set(key, (counts.get(key)||0)+1);
  }
  if (!counts.size) return "";

  let bestKey="", bestN=-1;
  for (const [k,n] of counts.entries()){
    if (n>bestN){ bestN=n; bestKey=k; }
  }
  return bestKey;
}

function processDockingPoseTable(data2D, sid){
  const header = (data2D[0] || []).map(safeTrim);
  const nameIdx = findCol(header, ["name"]);
  if (nameIdx<0) throw new Error("Docking 檔需包含 Name 欄位");
  const dsIdx = findCol(header, ["r_i_docking_score","docking_score"]);

  const interactionCols=[];
  for (let c=0;c<header.length;c++){
    const h=header[c];
    if (!h) continue;
    if (DOCK_KEYS.some(k=>h.includes(k))){
      const p = parseDockingInteractionColumn(h);
      if (p) interactionCols.push({ idx:c, ...p });
    }
  }
  if (!interactionCols.length){
    throw new Error("Docking 檔找不到 interaction 欄位（需含 HydrogenBond / Pi-Hydrophobic / AlkylHydrophobic / MixedPiAlkylHydrophobic）");
  }

  const { resToKlifs } = buildResidueMapsByStructureId(sid);
  if (!resToKlifs.size){
    throw new Error("alignment row 無法建立 residue→KLIFS mapping（可能該 row 大多為 '_'）");
  }

  const raw=[];
  for (let r=1;r<data2D.length;r++){
    const row=data2D[r];
    if (!row || row.every(v=>v==null || String(v).trim()==="")) continue;

    const name=safeTrim(row[nameIdx]);
    if (!name) continue;
    const ds = (dsIdx>=0) ? Number(row[dsIdx]) : NaN;

    const feat={};
    for (const ic of interactionCols){
      const val = Number(row[ic.idx]);
      const bin = Number.isFinite(val) && val >= 1 ? 1 : 0;
      if (!bin) continue;

      const klifsPos = resToKlifs.get(ic.residueNumber);
      if (!klifsPos) continue;
      feat[`${klifsPos}-${ic.kind}`] = 1;
    }
    raw.push({ Name:name, DS:ds, feat });
  }
  if (!raw.length) throw new Error("Docking 檔沒有有效資料列");

  const best = new Map();
  for (const r of raw){
    if (!best.has(r.Name)) best.set(r.Name, r);
    else{
      const cur = best.get(r.Name);
      const curOk = Number.isFinite(cur.DS);
      const newOk = Number.isFinite(r.DS);
      if (!curOk && newOk) best.set(r.Name, r);
      else if (curOk && newOk && r.DS < cur.DS) best.set(r.Name, r);
    }
  }
  const uniq = Array.from(best.values());

  const featureSet = new Set(klifsFeatureKeys);
  const dockBinary = uniq.map(r=>{
    const out={ Name:r.Name, DS:r.DS };
    for (const f of featureSet) out[f]=0;
    for (const k of Object.keys(r.feat)){
      if (featureSet.has(k)) out[k]=1;
    }
    return out;
  });

  const freq={ __n:dockBinary.length, __label:`Docking (n=${dockBinary.length})` };
  for (const f of featureSet){
    let sum=0;
    for (const r of dockBinary) sum += Number(r[f]) ? 1 : 0;
    freq[f] = dockBinary.length ? (sum/dockBinary.length)*100 : 0;
  }

  return { dockBinary, freq };
}

/* ===========================
   16) Diff plot + MDS
   =========================== */
function drawDiffPlot(dockFreq, klifsFreq, fmap){
  if (!dockFreq || !klifsFreq){
    Plotly.purge("diffPlot");
    return;
  }

  const items = klifsFeatureKeys.map(f=>{
    const d = Number(dockFreq[f]) || 0;
    const k = Number(klifsFreq[f]) || 0;
    return { f, dock:d, klifs:k, diff:(d-k) };
  }).sort((a,b)=>b.dock - a.dock);

  const x = items.map(it=>fmap.get(it.f) || it.f);
  const yDock = items.map(it=>it.dock);
  const yKlifs = items.map(it=>it.klifs);
  const yDiff = items.map(it=>it.diff);

  Plotly.newPlot("diffPlot", [
    { x, y:yDock,  type:"bar", name:"Docking freq (%)", yaxis:"y1" },
    { x, y:yKlifs, type:"bar", name:"KLIFS freq (%)",  yaxis:"y1" },
    { x, y:yDiff,  type:"scatter", mode:"lines+markers", name:"Diff (Dock - KLIFS)", yaxis:"y2" }
  ], {
    title:"Docking vs KLIFS (Freq + Diff) — KLIFS scope = current heatmap selection",
    xaxis:{ tickangle:-90, title:"Features" },
    yaxis:{ title:"Frequency (%)" },
    yaxis2:{ title:"Diff (%)", overlaying:"y", side:"right" },
    barmode:"group",
    margin:{ l:80, r:80, t:50, b:170 },
    height: 640,
    legend:{ orientation:"h" }
  }, { responsive:true });
}

function jaccardDistance(a,b){
  let inter=0, uni=0;
  for (let i=0;i<a.length;i++){
    const ai=a[i]?1:0, bi=b[i]?1:0;
    if (ai||bi) uni++;
    if (ai&&bi) inter++;
  }
  if (!uni) return 0;
  return 1 - inter/uni;
}
function pairwiseDistanceMatrix(vectors){
  const n=vectors.length;
  const D=Array.from({length:n},()=>Array(n).fill(0));
  for (let i=0;i<n;i++){
    for (let j=i+1;j<n;j++){
      const d=jaccardDistance(vectors[i],vectors[j]);
      D[i][j]=d; D[j][i]=d;
    }
  }
  return D;
}
function permanovaTest(D, labels, nPerm=199){
  const n=labels.length;
  const uniq=Array.from(new Set(labels));

  function ssWithin(lbls){
    let ss=0;
    for (const g of uniq){
      const idx=[];
      for (let i=0;i<n;i++) if (lbls[i]===g) idx.push(i);
      if (idx.length<=1) continue;
      let sum=0;
      for (let a=0;a<idx.length;a++){
        for (let b=0;b<idx.length;b++){
          const d=D[idx[a]][idx[b]];
          sum += d*d;
        }
      }
      ss += sum / idx.length;
    }
    return ss;
  }
  function ssBetween(lbls){
    let sumAll=0;
    for (let i=0;i<n;i++){
      for (let j=0;j<n;j++){
        const d=D[i][j];
        sumAll += d*d;
      }
    }
    const grand = sumAll/(n*n);
    let ss=0;
    for (const g of uniq){
      const idx=[];
      for (let i=0;i<n;i++) if (lbls[i]===g) idx.push(i);
      if (!idx.length) continue;
      let sum=0;
      for (let a=0;a<idx.length;a++){
        for (let b=0;b<idx.length;b++){
          const d=D[idx[a]][idx[b]];
          sum += d*d;
        }
      }
      const mean = sum/(idx.length*idx.length);
      ss += idx.length*(mean-grand)*(mean-grand);
    }
    return ss;
  }

  const ssW=ssWithin(labels);
  const ssB=ssBetween(labels);
  const Fobs = ssB/(ssW+1e-12);

  let count=0;
  for (let p=0;p<nPerm;p++){
    const perm=labels.slice();
    for (let i=n-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [perm[i],perm[j]]=[perm[j],perm[i]];
    }
    const Fp = ssBetween(perm)/(ssWithin(perm)+1e-12);
    if (Fp>=Fobs) count++;
  }
  const pval=(count+1)/(nPerm+1);
  return { F:Fobs, p:pval };
}
function mds2DFromDistance(D){
  const n=D.length;
  const D2=Array.from({length:n},()=>Array(n).fill(0));
  for (let i=0;i<n;i++) for (let j=0;j<n;j++) D2[i][j]=D[i][j]*D[i][j];

  const rowMean=Array(n).fill(0), colMean=Array(n).fill(0);
  for (let i=0;i<n;i++){
    let s=0; for (let j=0;j<n;j++) s+=D2[i][j];
    rowMean[i]=s/n;
  }
  for (let j=0;j<n;j++){
    let s=0; for (let i=0;i<n;i++) s+=D2[i][j];
    colMean[j]=s/n;
  }
  const grand = rowMean.reduce((a,b)=>a+b,0)/n;

  const B=Array.from({length:n},()=>Array(n).fill(0));
  for (let i=0;i<n;i++){
    for (let j=0;j<n;j++){
      B[i][j] = -0.5*(D2[i][j]-rowMean[i]-colMean[j]+grand);
    }
  }

  function matVec(M,v){
    const out=Array(M.length).fill(0);
    for (let i=0;i<M.length;i++){
      let s=0; for (let j=0;j<M.length;j++) s+=M[i][j]*v[j];
      out[i]=s;
    }
    return out;
  }
  function dot(a,b){ let s=0; for (let i=0;i<a.length;i++) s+=a[i]*b[i]; return s; }
  function norm(a){ return Math.sqrt(dot(a,a)) || 1; }
  function scale(a,k){ return a.map(x=>x*k); }

  function powerIter(M, it=220){
    let v=Array(M.length).fill(0).map(()=>Math.random()-0.5);
    v=scale(v, 1/norm(v));
    for (let t=0;t<it;t++){
      const w=matVec(M,v);
      v=scale(w, 1/norm(w));
    }
    const w=matVec(M,v);
    const lambda=dot(v,w);
    return { lambda, v };
  }

  const e1=powerIter(B,260);
  const B2=Array.from({length:n},(_,i)=>Array.from({length:n},(_,j)=>B[i][j]-e1.lambda*e1.v[i]*e1.v[j]));
  const e2=powerIter(B2,260);

  const l1=Math.max(e1.lambda,0), l2=Math.max(e2.lambda,0);
  const x=e1.v.map(v=>v*Math.sqrt(l1));
  const y=e2.v.map(v=>v*Math.sqrt(l2));
  return { x,y };
}
function drawMds(vectors, labels){
  if (vectors.length < 3){
    Plotly.purge("mdsPlot");
    return { perma:null, note:"樣本數太少，無法計算 MDS/PERMANOVA（需至少 3）" };
  }
  const D = pairwiseDistanceMatrix(vectors);
  const perma = permanovaTest(D, labels, 199);
  const mds = mds2DFromDistance(D);

  const xK=[], yK=[], xD=[], yD=[];
  for (let i=0;i<labels.length;i++){
    if (labels[i]==="KLIFS"){ xK.push(mds.x[i]); yK.push(mds.y[i]); }
    else { xD.push(mds.x[i]); yD.push(mds.y[i]); }
  }

  Plotly.newPlot("mdsPlot", [
    { x:xK, y:yK, type:"scatter", mode:"markers", name:`KLIFS (n=${xK.length})`, opacity:0.45, marker:{ size:9, symbol:"triangle-up" } },
    { x:xD, y:yD, type:"scatter", mode:"markers", name:`Docking (n=${xD.length})`, opacity:0.85, marker:{ size:8 } }
  ], {
    title:"MDS (Jaccard distance) — KLIFS scope = current heatmap selection",
    xaxis:{ title:"Dim 1" },
    yaxis:{ title:"Dim 2" },
    margin:{ l:70, r:20, t:50, b:50 },
    height:620,
    legend:{ orientation:"h" }
  }, { responsive:true });

  return { perma };
}

/* ===========================
   17) Confusion matrix + metrics
   =========================== */
function safeDiv(a,b){
  if (!Number.isFinite(a) || !Number.isFinite(b) || b===0) return NaN;
  return a/b;
}
function computeConfusionAndMetrics(dockFreq, klifsFreq, klifsPosThresh01){
  const dockTruthThresh = 50;                 // percent
  const klifsPredThresh = Math.max(0, Math.min(1, Number(klifsPosThresh01))) * 100;

  let TP=0, FP=0, TN=0, FN=0;

  for (const f of klifsFeatureKeys){
    const d = Number(dockFreq[f]) || 0;
    const k = Number(klifsFreq[f]) || 0;

    const truthPos = d >= dockTruthThresh;
    const predPos  = k >= klifsPredThresh;

    if (truthPos && predPos) TP++;
    else if (!truthPos && predPos) FP++;
    else if (!truthPos && !predPos) TN++;
    else if (truthPos && !predPos) FN++;
  }

  const precision = safeDiv(TP, TP+FP);
  const recall    = safeDiv(TP, TP+FN); // sensitivity
  const specificity = safeDiv(TN, TN+FP);
  const accuracy  = safeDiv(TP+TN, TP+TN+FP+FN);
  const f1 = (Number.isFinite(precision) && Number.isFinite(recall) && (precision+recall)>0)
    ? (2*precision*recall/(precision+recall))
    : NaN;
  const fpr = safeDiv(FP, FP+TN);
  const fnr = safeDiv(FN, FN+TP);

  // MCC
  const denom = Math.sqrt((TP+FP)*(TP+FN)*(TN+FP)*(TN+FN));
  const mcc = denom ? (TP*TN - FP*FN)/denom : NaN;

  return {
    thresholds: { dockTruthThreshPct: dockTruthThresh, klifsPredThreshPct: klifsPredThresh },
    confusion: { TP, FP, TN, FN, total: TP+FP+TN+FN },
    metrics: { precision, recall, sensitivity:recall, specificity, accuracy, f1, fpr, fnr, mcc }
  };
}

function drawConfusionPlot(conf){
  if (!conf) { Plotly.purge("confusionPlot"); return; }
  const { TP, FP, TN, FN } = conf.confusion;

  // 2x2: rows = Truth (Positive/Negative), cols = Pred (Positive/Negative)
  const z = [
    [TP, FN],  // Truth Positive: Pred Pos (TP), Pred Neg (FN)
    [FP, TN]   // Truth Negative: Pred Pos (FP), Pred Neg (TN)
  ];
  const x = ["Pred Positive", "Pred Negative"];
  const y = ["Truth Positive (Dock≥50%)", "Truth Negative (Dock<50%)"];

  const text = [
    [`TP<br>${TP}`, `FN<br>${FN}`],
    [`FP<br>${FP}`, `TN<br>${TN}`]
  ];

  Plotly.newPlot("confusionPlot", [{
    type:"heatmap",
    x, y, z,
    text,
    texttemplate: "%{text}",
    hovertemplate: "%{y} | %{x}<br>Count=%{z}<extra></extra>",
    showscale:false
  }], {
    title: "Confusion Matrix (feature-level)",
    xaxis:{ title:"Prediction (KLIFS thresholded)" },
    yaxis:{ title:"Ground truth (Docking thresholded)" },
    margin:{ l:220, r:20, t:60, b:70 },
    height: 520
  }, { responsive:true });
}

function renderMetricsCards(obj){
  metricsCards.innerHTML = "";
  metricsNote.textContent = "";
  if (!obj) return;

  const m = obj.metrics;
  const c = obj.confusion;
  const t = obj.thresholds;

  const fmt = (v) => Number.isFinite(v) ? v.toFixed(4) : "NA";

  const cards = [
    { k:"TP / FP / TN / FN", v:`${c.TP} / ${c.FP} / ${c.TN} / ${c.FN}` },
    { k:"Recall (Sensitivity)", v: fmt(m.recall) },
    { k:"Specificity", v: fmt(m.specificity) },
    { k:"Precision", v: fmt(m.precision) },
    { k:"F1-score", v: fmt(m.f1) },
    { k:"Accuracy", v: fmt(m.accuracy) },
    { k:"FPR", v: fmt(m.fpr) },
    { k:"FNR", v: fmt(m.fnr) },
    { k:"MCC", v: fmt(m.mcc) },
  ];

  for (const it of cards){
    const div = document.createElement("div");
    div.className = "card";
    div.innerHTML = `<div class="k">${it.k}</div><div class="v">${it.v}</div>`;
    metricsCards.appendChild(div);
  }

  metricsNote.textContent =
    `Thresholds: Dock truth ≥ ${t.dockTruthThreshPct}% ; KLIFS predicted ≥ ${t.klifsPredThreshPct.toFixed(2)}% (input=${(t.klifsPredThreshPct/100).toFixed(2)})`;
}

/* ===========================
   18) Compare handler + recompute (Step 1–4 integrated)
   =========================== */
function recomputeCompareStatsIfAvailable(){
  if (!residueModeActive || !dockFreqRow) return;

  // KLIFS scope = current heatmap selection
  const klifsStruct = getKlifsStructBinaryFromCurrentSelection();
  if (!klifsStruct.length){
    summaryInfo.innerHTML = `<span class="danger">已 Compare，但目前 selection 找不到任何 KLIFS structures（請調整 viewMode/selection）。</span>`;
    Plotly.purge("diffPlot");
    Plotly.purge("mdsPlot");
    Plotly.purge("confusionPlot");
    metricsCards.innerHTML = "";
    metricsNote.textContent = "";
    lastCompareKlifsStruct = [];
    lastCompareKlifsFreq = null;
    lastMetrics = null;
    lastMds = null;
    refreshUiLocks();
    return;
  }

  const klifsFreq = computeFreqFromBinaryRows(klifsStruct);
  lastCompareKlifsStruct = klifsStruct.slice();
  lastCompareKlifsFreq = klifsFreq;

  // diff
  drawDiffPlot(dockFreqRow, klifsFreq, residueFeatureMap);

  // MDS/PERMANOVA
  const klifsVec = klifsStruct.map(r=>klifsFeatureKeys.map(f=>Number(r[f])?1:0));
  const dockVec  = dockBinaryRows.map(r=>klifsFeatureKeys.map(f=>Number(r[f])?1:0));
  const vectors=[], labels=[];
  for (const v of klifsVec){ vectors.push(v); labels.push("KLIFS"); }
  for (const v of dockVec){ vectors.push(v); labels.push("Docking"); }
  const mdsRes = drawMds(vectors, labels);
  lastMds = mdsRes;

  const permaText = mdsRes?.perma
    ? `PERMANOVA F=${mdsRes.perma.F.toFixed(4)}, p=${mdsRes.perma.p.toFixed(4)}`
    : (mdsRes?.note || "PERMANOVA unavailable");

  // confusion + metrics
  const th = Number(klifsThreshInput.value);
  const confObj = computeConfusionAndMetrics(dockFreqRow, klifsFreq, Number.isFinite(th)?th:0.5);
  lastMetrics = confObj;

  drawConfusionPlot(confObj);
  renderMetricsCards(confObj);

  const alignedSid = lastDockAlignmentSid ? lastDockAlignmentSid : "(unknown)";
  const picked = getSelectedValues();
  const pickedText = picked.length ? `${picked.length} selected` : "ALL";

  summaryInfo.innerHTML =
    `Compare：<span class="pill">Docking vs KLIFS</span>　` +
    `Alignment row：<span class="pill">${alignedSid}</span>　` +
    `Docking ligands：<span class="pill">${dockFreqRow.__n}</span>　` +
    `KLIFS structures(selection)：<span class="pill">${klifsStruct.length}</span>　` +
    `ViewMode：<span class="pill">${viewModeSelect.value}</span>　` +
    `Picked：<span class="pill">${pickedText}</span>　` +
    `<span class="pill">X-label locked: residue</span><br/>` +
    `${permaText}`;

  refreshUiLocks();
}

compareBtn.addEventListener("click", ()=>{
  try{
    if (!(metaLoaded && klifsLoaded && alignLoaded && dockLoaded)){
      alert("Compare 需要：meta + KLIFS IFP + alignment + docking 都已上傳。");
      return;
    }
    const dk = safeTrim(dockKinaseInput.value);
    if (!dk){
      alert("請先輸入 docking kinase（例如 CLK4）。");
      return;
    }

    const manualPdb = safeTrim(dockPdbInput.value);
    const inferredPdbNorm = inferDockingPdbFromDockTable(dockRaw2D);
    const preferredPdb = manualPdb ? manualPdb : inferredPdbNorm;

    const sid = autoPickAlignmentStructureIdForDockingKinase(dk, preferredPdb);
    if (!sid){
      alert(
        "無法自動配對 alignment row。\n請確認：\n" +
        "1) alignment xlsx 的 kinase 欄位包含你輸入的 docking kinase 名稱\n" +
        "2) alignment xlsx 的 structure_ID 欄位有值\n" +
        "3) 若同 kinase 多個 structure_ID：alignment 的 pdb 欄(若有)能與 docking 的 pdb 對上"
      );
      return;
    }
    lastDockAlignmentSid = sid;

    // lock residue labels
    const fmap = new Map();
    for (const f of klifsFeatureKeys) fmap.set(f, f);
    const { klifsToRes } = buildResidueMapsByStructureId(sid);
    for (const f of klifsFeatureKeys){
      const m = String(f).match(/^(\d+)\-(HP|HB)$/i);
      if (!m) continue;
      const pos=parseInt(m[1],10);
      const kind=m[2].toUpperCase();
      const res=klifsToRes.get(pos);
      if (res) fmap.set(f, `${res}-${kind}`);
    }
    residueModeActive = true;
    residueFeatureMap = fmap;

    // docking -> binary & freq
    const proc = processDockingPoseTable(dockRaw2D, sid);
    dockBinaryRows = proc.dockBinary;
    dockFreqRow = proc.freq;

    // redraw KLIFS heatmap with residue labels (keep current selection)
    const rows = getKlifsHeatmapRowsByCurrentSelection();
    lastKlifsRows = rows.slice();
    drawHeatmap("klifsHeatmap", rows, residueFeatureMap, "KLIFS Interaction Frequency Heatmap (%)");
    drawHeatmap("dockHeatmap", [dockFreqRow], residueFeatureMap, `Docking Heatmap (Aligned) — using alignment structure_ID=${sid}`);

    // init analysis threshold default enabled
    if (!klifsThreshInput.value) klifsThreshInput.value = "0.50";

    // recompute analysis using selection-based scope
    recomputeCompareStatsIfAvailable();

  }catch(err){
    console.error(err);
    alert("Compare 失敗：" + err.message);
  }finally{
    refreshUiLocks();
  }
});

recalcAnalysisBtn.addEventListener("click", ()=>{
  recomputeCompareStatsIfAvailable();
});
klifsThreshInput.addEventListener("input", ()=>{
  if (!residueModeActive) return;
  // lightweight update
  recomputeCompareStatsIfAvailable();
});

/* ===========================
   19) Reset (keep files loaded; reset UI + plots)
   =========================== */
function resetWorkflowState(){
  viewModeSelect.value = "kinase";
  featureLabelModeSelect.value = "auto";
  dockPdbInput.value = "";

  selectedList.innerHTML = "";
  rebuildAvailableSelectedLists(true);

  Plotly.purge("klifsHeatmap");
  Plotly.purge("dockHeatmap");
  Plotly.purge("diffPlot");
  Plotly.purge("mdsPlot");
  Plotly.purge("confusionPlot");

  summaryInfo.innerHTML = "";
  lastKlifsRows = [];
  residueModeActive = false;
  residueFeatureMap = new Map();
  dockBinaryRows = [];
  dockFreqRow = null;
  lastDockAlignmentSid = "";
  lastCompareKlifsStruct = [];
  lastCompareKlifsFreq = null;
  lastMetrics = null;
  lastMds = null;

  metricsCards.innerHTML = "";
  metricsNote.textContent = "";

  setStatus("已重置設定（檔案仍保留已載入狀態）。你可以重新選 viewMode / 清單後再更新 heatmap。");
  refreshUiLocks();
}

resetBtn.addEventListener("click", ()=>{
  if (!(metaLoaded && klifsLoaded)) return;
  resetWorkflowState();
});

/* ===========================
   20) Export: Plot PNG
   =========================== */
async function exportPlotPng(divId, filename){
  const div = document.getElementById(divId);
  if (!div || !div.data) {
    alert(`找不到可匯出的圖：${divId}`);
    return;
  }
  try{
    const url = await Plotly.toImage(div, { format:"png", height:div.layout?.height || 700, width:1200, scale:2 });
    const res = await fetch(url);
    const blob = await res.blob();
    downloadBlob(blob, filename);
  }catch(err){
    console.error(err);
    alert("匯出 PNG 失敗：" + err.message);
  }
}

exportKlifsPngBtn.addEventListener("click", ()=>exportPlotPng("klifsHeatmap", "KLIFS_heatmap.png"));
exportDockPngBtn.addEventListener("click",  ()=>exportPlotPng("dockHeatmap",  "Docking_heatmap.png"));
exportDiffPngBtn.addEventListener("click",  ()=>exportPlotPng("diffPlot",      "Docking_vs_KLIFS_diff.png"));
exportMdsPngBtn.addEventListener("click",   ()=>exportPlotPng("mdsPlot",       "MDS.png"));
exportConfPngBtn.addEventListener("click",  ()=>exportPlotPng("confusionPlot", "Confusion_matrix.png"));

exportAllPngBtn.addEventListener("click", async ()=>{
  await exportPlotPng("klifsHeatmap", "KLIFS_heatmap.png");
  if (residueModeActive) await exportPlotPng("dockHeatmap", "Docking_heatmap.png");
  if (residueModeActive) await exportPlotPng("diffPlot", "Docking_vs_KLIFS_diff.png");
  if (residueModeActive) await exportPlotPng("mdsPlot", "MDS.png");
  if (residueModeActive) await exportPlotPng("confusionPlot", "Confusion_matrix.png");
});

/* ===========================
   21) Export: Excel (heatmap + metrics)
   =========================== */
function makeSheetFromRows(header, rows){
  return XLSX.utils.aoa_to_sheet([header, ...rows]);
}
function getCurrentXLabels(){
  const fmap = residueModeActive ? residueFeatureMap : buildFeatureDisplayMapForKlifs();
  return klifsFeatureKeys.map(f => fmap.get(f) || f);
}
function buildHeatmapExportTableRows(rows){
  const x = getCurrentXLabels();
  const header = ["RowLabel", ...x];
  const body = rows.map(r=>{
    const label = r.__label ?? r[kinaseKeyName] ?? "";
    const vals = klifsFeatureKeys.map(f => {
      const v = Number(r[f]);
      return Number.isFinite(v) ? v : 0;
    });
    return [label, ...vals];
  });
  return { header, body };
}
function buildSummarySheet(){
  const vm = viewModeSelect.value || "";
  const picked = getSelectedValues();
  const pickedText = picked.length ? picked.join("; ") : "(ALL)";
  const dk = safeTrim(dockKinaseInput.value);
  const sid = lastDockAlignmentSid || "";
  const dkPdb = safeTrim(dockPdbInput.value);
  const klifsN = lastCompareKlifsStruct?.length || 0;
  const dockN = dockFreqRow?.__n || 0;

  const perma = lastMds?.perma;
  const permaText = perma ? `F=${perma.F}, p=${perma.p}` : (lastMds?.note || "");

  const rows = [
    ["GeneratedAt", new Date().toISOString()],
    ["ViewMode", vm],
    ["Selected", pickedText],
    ["DockingKinase", dk],
    ["AlignmentStructureID", sid],
    ["DockPDBManual", dkPdb],
    ["DockingLigandsN", dockN],
    ["KLIFSStructuresN(selection)", klifsN],
    ["PERMANOVA", permaText],
    ["KLIFS_Positive_Threshold(0-1)", klifsThreshInput.value || ""],
  ];
  return XLSX.utils.aoa_to_sheet([["Key","Value"], ...rows]);
}

exportExcelBtn.addEventListener("click", ()=>{
  try{
    if (!(metaLoaded && klifsLoaded)){
      alert("請先載入 meta + KLIFS IFP");
      return;
    }

    const wb = XLSX.utils.book_new();

    // KLIFS heatmap (current view)
    const klifsRowsForExport = lastKlifsRows.length ? lastKlifsRows : getKlifsHeatmapRowsByCurrentSelection();
    const t1 = buildHeatmapExportTableRows(klifsRowsForExport);
    XLSX.utils.book_append_sheet(wb, makeSheetFromRows(t1.header, t1.body), "KLIFS_heatmap");

    // Docking heatmap (if compare done)
    if (residueModeActive && dockFreqRow){
      const t2 = buildHeatmapExportTableRows([dockFreqRow]);
      XLSX.utils.book_append_sheet(wb, makeSheetFromRows(t2.header, t2.body), "Docking_heatmap");
    }

    // Confusion + metrics
    if (residueModeActive && lastMetrics){
      const c = lastMetrics.confusion;
      const m = lastMetrics.metrics;
      const t = lastMetrics.thresholds;

      const confSheet = XLSX.utils.aoa_to_sheet([
        ["", "Pred Positive", "Pred Negative"],
        ["Truth Positive (Dock≥50%)", c.TP, c.FN],
        ["Truth Negative (Dock<50%)", c.FP, c.TN],
        ["Total", c.total, ""],
        ["DockTruthThreshold(%)", t.dockTruthThreshPct, ""],
        ["KLIFSPredThreshold(%)", t.klifsPredThreshPct, ""],
      ]);
      XLSX.utils.book_append_sheet(wb, confSheet, "Confusion");

      const fmt = (v)=>Number.isFinite(v)?v: "";
      const metricsSheet = XLSX.utils.aoa_to_sheet([
        ["Metric", "Value"],
        ["Precision", fmt(m.precision)],
        ["Recall/Sensitivity", fmt(m.recall)],
        ["Specificity", fmt(m.specificity)],
        ["Accuracy", fmt(m.accuracy)],
        ["F1", fmt(m.f1)],
        ["FPR", fmt(m.fpr)],
        ["FNR", fmt(m.fnr)],
        ["MCC", fmt(m.mcc)],
      ]);
      XLSX.utils.book_append_sheet(wb, metricsSheet, "Metrics");
    }

    // Summary sheet
    XLSX.utils.book_append_sheet(wb, buildSummarySheet(), "Summary");

    const out = XLSX.write(wb, { bookType:"xlsx", type:"array" });
    downloadBlob(new Blob([out], { type:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" }), "IFP_compare_export.xlsx");

  }catch(err){
    console.error(err);
    alert("匯出 Excel 失敗：" + err.message);
  }
});

/* ===========================
   22) Init + enable file chaining
   =========================== */
function enableFileChaining(){
  // after meta loaded -> klifs input enabled by refreshUiLocks
}

refreshUiLocks();
viewModeSelect.value = "kinase";
featureLabelModeSelect.value = "auto";

/* enable plot exports as soon as data plotted */
function onPlotRendered(){
  exportKlifsPngBtn.disabled = !(metaLoaded && klifsLoaded);
  exportDockPngBtn.disabled  = !(residueModeActive && dockFreqRow);
  exportAllPngBtn.disabled   = !(metaLoaded && klifsLoaded);
  exportExcelBtn.disabled    = !(metaLoaded && klifsLoaded);
}
setInterval(onPlotRendered, 600);
</script>
</body>
</html>
