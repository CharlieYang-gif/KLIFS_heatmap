<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Kinase IFP Heatmap Tool_V3 (Auto-detect)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    body { font-family: system-ui, sans-serif; margin: 0; padding: 1rem 2rem; background: #f5f5f5; color: #333; }
    .panel { background: #fff; border-radius: 12px; padding: 1.5rem; margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    h1 { color: #1f7ae0; }
    .flex-row { display: flex; flex-wrap: wrap; gap: 1rem; align-items: flex-end; }
    .field { margin-bottom: 0.5rem; }
    label { font-weight: 600; display: block; margin-bottom: 4px; }
    input, select, textarea { padding: 0.5rem; border-radius: 6px; border: 1px solid #ccc; font-size: 0.9rem; }
    button { padding: 0.6rem 1.2rem; border-radius: 6px; border: none; cursor: pointer; background: #1f7ae0; color: white; font-weight: 600; transition: 0.2s; }
    button:hover { background: #155cb0; }
    button:disabled { background: #ccc; cursor: not-allowed; }
    #heatmap { width: 100%; min-height: 600px; margin-top: 1rem; border: 1px solid #eee; }
    table { border-collapse: collapse; width: 100%; display: block; max-height: 400px; overflow: auto; border: 1px solid #ddd; }
    th, td { border: 1px solid #ddd; padding: 8px; font-size: 12px; text-align: center; }
    th { background: #f8f9fa; position: sticky; top: 0; }
    .dual-list-container { display: flex; gap: 1rem; margin-top: 1rem; }
    .dual-list-column { flex: 1; display: flex; flex-direction: column; }
    .dual-list-select { min-height: 200px; }
    .status-msg { font-weight: bold; margin-left: 10px; }
    .muted { color: #666; font-size: 0.85rem; margin-top: 5px; }
  </style>
</head>
<body>

  <h1>Kinase Interaction Fingerprint Heatmap</h1>

  <div class="panel">
    <h2>1. è¼‰å…¥è³‡æ–™</h2>
    <div class="flex-row">
      <div class="field">
        <label>ä¸Šå‚³æ–°ç‰ˆ Excel (.xlsx)</label>
        <input type="file" id="fileInput" accept=".xlsx" />
      </div>
      <div class="field">
        <label>Meta è¡Œæ•¸ (æ¨™é ­)</label>
        <input type="number" id="metaRows" value="5" min="1" />
      </div>
      <button id="processBtn" disabled>åŸ·è¡Œè‡ªå‹•è¾¨è­˜èˆ‡åˆ†æ</button>
      <span id="statusText" class="status-msg">æ­£åœ¨è¼‰å…¥é è¨­è³‡æ–™...</span>
    </div>
    <div class="muted">ğŸ’¡ ç¨‹å¼æœƒè‡ªå‹•å°‹æ‰¾æ¨™é¡ŒåŒ…å« "IFP" çš„æ¬„ä½ï¼Œä¸è«–ä½ç½®åœ¨é‚£è£¡ã€‚</div>
    <div class="field" style="margin-top:10px;">
      <input type="checkbox" id="collapseHpHb" checked />
      <label style="display:inline;" for="collapseHpHb">æ•´åˆ IFP 1-3 (HP) èˆ‡ 4-7 (HB)</label>
    </div>
  </div>

  <div class="panel">
    <h2>2. ç¯©é¸èˆ‡é¸æ“‡ Kinase</h2>
    <div class="flex-row">
      <div class="field">
        <label>Family ç¯©é¸</label>
        <select id="familyFilter"><option value="">å…¨éƒ¨</option></select>
      </div>
      <div class="field">
        <label>Group ç¯©é¸</label>
        <select id="groupFilter"><option value="">å…¨éƒ¨</option></select>
      </div>
    </div>
    
    <div class="dual-list-container">
      <div class="dual-list-column">
        <label>å¯é¸ Kinase</label>
        <input type="text" id="kinaseSearch" placeholder="æœå°‹åç¨±..." style="margin-bottom:5px;">
        <select id="availableKinases" multiple class="dual-list-select"></select>
      </div>
      <div class="dual-list-column" style="flex:0; justify-content:center; gap:10px;">
        <button id="addKinaseBtn"> &gt;&gt; </button>
        <button id="removeKinaseBtn"> &lt;&lt; </button>
      </div>
      <div class="dual-list-column">
        <label>å·²é¸ Kinase (Heatmap é¡¯ç¤ºå°è±¡)</label>
        <select id="selectedKinases" multiple class="dual-list-select"></select>
      </div>
    </div>
    <button id="updatePlotBtn" style="margin-top:1rem;" disabled>æ›´æ–° Heatmap è¦–åœ–</button>
  </div>

  <div class="panel">
    <div class="flex-row" style="justify-content: space-between;">
      <h2>3. Heatmap èˆ‡æ•¸æ“šä¸‹è¼‰</h2>
      <div>
        <button id="downloadCsvBtn" disabled>ä¸‹è¼‰ç›®å‰è³‡æ–™ (CSV)</button>
        <button id="downloadPngBtn" disabled>ä¸‹è¼‰åœ–ç‰‡ (PNG)</button>
      </div>
    </div>
    <div id="heatmap"></div>
    <h3>å„äº¤äº’ä½œç”¨ç‰¹å¾µ (Feature) å¹³å‡ç™¼ç”Ÿç‡</h3>
    <div id="featureStatsContainer"></div>
  </div>

  <script>
    // --- é…ç½®èˆ‡å…¨å±€è®Šæ•¸ ---
    const CONFIG = {
      IFP_XLSX_URL: "https://raw.githubusercontent.com/CharlieYang-gif/KLIFS_heatmap/main/20241001_KLIFS_IFP595_ID.xlsx",
      META_CSV_URL: "https://raw.githubusercontent.com/CharlieYang-gif/KLIFS_heatmap/main/KLIFS_export.csv"
    };

    let rawData = null; 
    let kinaseFreqMatrix = null;
    let featureNames = [];
    let kinaseNames = [];
    let kinaseMetaMap = {}; 
    const kinaseKeyName = "kinase"; 

    // --- DOM å…ƒç´  ---
    const el = (id) => document.getElementById(id);
    const ui = {
      fileInput: el("fileInput"),
      processBtn: el("processBtn"),
      status: el("statusText"),
      available: el("availableKinases"),
      selected: el("selectedKinases"),
      search: el("kinaseSearch"),
      family: el("familyFilter"),
      group: el("groupFilter"),
      heatmap: el("heatmap")
    };

    // --- æ ¸å¿ƒé‚è¼¯ï¼šè‡ªå‹•åµæ¸¬ IFP æ¬„ä½ ---
    function getIfpColumnIndices(headerRow) {
      return headerRow.reduce((acc, cell, idx) => {
        if (cell && String(cell).toUpperCase().includes("IFP")) acc.push(idx);
        return acc;
      }, []);
    }

    // --- è³‡æ–™è™•ç† ---
    function processData() {
      if (!rawData) return;
      const nMetaRows = parseInt(el("metaRows").value) || 5;
      const collapse = el("collapseHpHb").checked;
      const headerRow = rawData[0];
      const ifpIndices = getIfpColumnIndices(headerRow);

      if (ifpIndices.length === 0) {
        alert("æ‰¾ä¸åˆ°åŒ…å« 'IFP' çš„æ¬„ä½ï¼è«‹æª¢æŸ¥ Excel ç¬¬ä¸€åˆ—ã€‚");
        return;
      }

      let processedRows = [];
      if (collapse) {
        // HP/HB æ•´åˆé‚è¼¯ (Position æ˜¯ç¬¬ 2 åˆ—, Type æ˜¯ç¬¬ 3 åˆ—)
        const posRow = rawData[1];
        const typeRow = rawData[2];
        const hpTypes = [1, 2, 3], hbTypes = [4, 5, 6, 7];

        for (let i = nMetaRows; i < rawData.length; i++) {
          const row = rawData[i];
          if (!row[0]) continue;
          let obj = { kinase: row[2] || "Unknown" }; 
          
          ifpIndices.forEach(idx => {
            const pos = posRow[idx] + 1; // é¡¯ç¤ºå¾ 1 é–‹å§‹
            const type = parseInt(typeRow[idx]);
            const val = parseInt(row[idx]) || 0;

            if (hpTypes.includes(type)) {
              obj[`${pos}-HP`] = (obj[`${pos}-HP`] || 0) | val;
            } else if (hbTypes.includes(type)) {
              obj[`${pos}-HB`] = (obj[`${pos}-HB`] || 0) | val;
            }
          });
          processedRows.push(obj);
        }
      } else {
        // åŸå§‹ Bits æ¨¡å¼
        for (let i = nMetaRows; i < rawData.length; i++) {
          const row = rawData[i];
          if (!row[0]) continue;
          let obj = { kinase: row[2] || "Unknown" };
          ifpIndices.forEach(idx => {
            obj[headerRow[idx]] = parseInt(row[idx]) || 0;
          });
          processedRows.push(obj);
        }
      }

      // è¨ˆç®—é »ç‡
      const grouped = processedRows.reduce((acc, row) => {
        if (!acc[row.kinase]) acc[row.kinase] = [];
        acc[row.kinase].push(row);
        return acc;
      }, {});

      const allFeatures = Object.keys(processedRows[0]).filter(k => k !== 'kinase');
      featureNames = allFeatures.sort((a,b) => parseInt(a) - parseInt(b));
      
      kinaseFreqMatrix = Object.keys(grouped).map(k => {
        let res = { kinase: k };
        allFeatures.forEach(f => {
          const sum = grouped[k].reduce((s, r) => s + (r[f] || 0), 0);
          res[f] = (sum / grouped[k].length) * 100;
        });
        return res;
      });

      kinaseNames = Object.keys(grouped).sort();
      updateKinaseLists();
      el("updatePlotBtn").disabled = false;
      el("downloadCsvBtn").disabled = false;
      el("downloadPngBtn").disabled = false;
      ui.status.textContent = "åˆ†æå®Œæˆï¼";
      drawHeatmap();
    }

    // --- UI æ›´æ–°èˆ‡äº‹ä»¶ ---
    function updateKinaseLists() {
      const query = ui.search.value.toLowerCase();
      const selSet = new Set(Array.from(ui.selected.options).map(o => o.value));
      
      ui.available.innerHTML = "";
      kinaseNames.filter(k => !selSet.has(k) && k.toLowerCase().includes(query)).forEach(k => {
        ui.available.add(new Option(k, k));
      });
    }

    function drawHeatmap() {
      const selected = Array.from(ui.selected.options).map(o => o.value);
      const dataRows = (selected.length > 0 ? 
        kinaseFreqMatrix.filter(r => selected.includes(r.kinase)) : 
        kinaseFreqMatrix).filter(r => {
          const meta = kinaseMetaMap[r.kinase] || {};
          return (!ui.family.value || meta.family === ui.family.value) &&
                 (!ui.group.value || meta.group === ui.group.value);
        });

      if (dataRows.length === 0) return;

      const z = dataRows.map(r => featureNames.map(f => r[f]));
      const y = dataRows.map(r => r.kinase);

      const trace = {
        z: z, x: featureNames, y: y,
        type: 'heatmap', colorscale: 'Viridis',
        colorbar: { title: '%' }
      };

      const layout = {
        title: 'Kinase Interaction Frequency',
        xaxis: { tickangle: -90, automargin: true },
        yaxis: { automargin: true },
        height: Math.max(600, y.length * 20 + 200)
      };

      Plotly.newPlot('heatmap', [trace], layout);
      renderStats(dataRows);
    }

    function renderStats(rows) {
      const stats = featureNames.map(f => {
        const avg = rows.reduce((s, r) => s + r[f], 0) / rows.length;
        return { feature: f, avg: avg };
      }).sort((a,b) => b.avg - a.avg);

      let html = "<table><tr><th>Feature</th><th>Mean %</th></tr>";
      stats.slice(0, 50).forEach(s => {
        html += `<tr><td>${s.feature}</td><td>${s.avg.toFixed(1)}%</td></tr>`;
      });
      el("featureStatsContainer").innerHTML = html + "</table>";
    }

    // --- åˆå§‹åŒ–èˆ‡æª”æ¡ˆè®€å– ---
    ui.fileInput.onchange = (e) => {
      const reader = new FileReader();
      reader.onload = (evt) => {
        const wb = XLSX.read(evt.target.result, {type:'array'});
        rawData = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]], {header:1});
        ui.processBtn.disabled = false;
        ui.status.textContent = "æœ¬æ©Ÿæª”æ¡ˆè¼‰å…¥æˆåŠŸ";
      };
      reader.readAsArrayBuffer(e.target.files[0]);
    };

    ui.processBtn.onclick = processData;
    ui.updatePlotBtn.onclick = drawHeatmap;
    ui.search.oninput = updateKinaseLists;
    
    el("addKinaseBtn").onclick = () => {
      Array.from(ui.available.selectedOptions).forEach(o => ui.selected.add(new Option(o.text, o.value)));
      updateKinaseLists();
    };
    el("removeKinaseBtn").onclick = () => {
      Array.from(ui.selected.selectedOptions).forEach(o => o.remove());
      updateKinaseLists();
    };

    // ä¸‹è¼‰åŠŸèƒ½
    el("downloadCsvBtn").onclick = () => {
        let csv = "kinase," + featureNames.join(",") + "\n";
        kinaseFreqMatrix.forEach(r => {
            csv += r.kinase + "," + featureNames.map(f => r[f].toFixed(2)).join(",") + "\n";
        });
        const blob = new Blob([csv], {type:'text/csv'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = "kinase_ifp_frequency.csv"; a.click();
    };

    el("downloadPngBtn").onclick = () => {
        Plotly.downloadImage('heatmap', {format:'png', filename:'kinase_heatmap'});
    };

    // å•Ÿå‹•æ™‚è‡ªå‹•è¼‰å…¥ GitHub è³‡æº
    async function init() {
      try {
        const [ifpRes, metaRes] = await Promise.all([
          fetch(CONFIG.IFP_XLSX_URL).then(r => r.arrayBuffer()),
          fetch(CONFIG.META_CSV_URL).then(r => r.text())
        ]);
        
        // è™•ç† Meta
        const metaRows = metaRes.split("\n").map(r => r.split(","));
        const h = metaRows[0];
        const iN = h.indexOf("NAME"), iF = h.indexOf("FAMILY"), iG = h.indexOf("GROUPS");
        const families = new Set(), groups = new Set();
        
        metaRows.slice(1).forEach(r => {
          if(!r[iN]) return;
          kinaseMetaMap[r[iN]] = { family: r[iF], group: r[iG] };
          if(r[iF]) families.add(r[iF]);
          if(r[iG]) groups.add(r[iG]);
        });
        
        Array.from(families).sort().forEach(f => ui.family.add(new Option(f, f)));
        Array.from(groups).sort().forEach(g => ui.group.add(new Option(g, g)));

        // è™•ç† Excel
        const wb = XLSX.read(ifpRes, {type:'array'});
        rawData = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]], {header:1});
        
        ui.processBtn.disabled = false;
        ui.status.textContent = "GitHub è³‡æ–™è¼‰å…¥æˆåŠŸ";
      } catch (e) {
        ui.status.textContent = "GitHub è¼‰å…¥å¤±æ•—ï¼Œè«‹æ‰‹å‹•ä¸Šå‚³æª”æ¡ˆ";
      }
    }

    init();
  </script>
</body>
</html>
