<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Kinase IFP Heatmap Tool (KLIFS-only + Docking Compare)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:0; padding:16px 24px; background:#f5f5f5; color:#333; }
    .panel { background:#fff; border-radius:12px; padding:18px 20px; margin-bottom:16px; box-shadow:0 2px 8px rgba(0,0,0,0.08); }
    h1 { margin:0 0 12px 0; color:#1f7ae0; }
    h2 { margin:0 0 10px 0; }
    .muted { color:#666; font-size:13px; line-height:1.55; }
    .small { font-size:12px; }
    .flex-row { display:flex; flex-wrap:wrap; gap:12px; align-items:flex-end; }
    .field { min-width:260px; }
    label { font-weight:800; display:block; margin-bottom:6px; }
    input[type="file"], input[type="text"], select, button { border:1px solid #ccc; border-radius:10px; padding:10px; font-size:13px; background:#fff; }
    button { background:#1f7ae0; color:#fff; border:none; font-weight:800; cursor:pointer; }
    button:hover { background:#155cb0; }
    button:disabled { background:#ccc; cursor:not-allowed; }
    input:disabled, select:disabled { background:#f1f1f1; cursor:not-allowed; }
    .status { font-weight:900; color:#b26a00; }
    .pill { display:inline-block; padding:2px 10px; border-radius:999px; background:#eef4ff; color:#1f7ae0; font-weight:900; font-size:12px; }
    .danger { color:#c0392b; font-weight:900; }
    .ok { color:#2e7d32; font-weight:900; }
    hr { border:0; border-top:1px solid #eee; margin:14px 0; }
    #heatmap, #diffPlot, #mdsPlot { width:100%; min-height:520px; margin-top:10px; background:#fff; border:1px solid #eee; border-radius:12px; }
    table { border-collapse:collapse; width:100%; border:1px solid #ddd; border-radius:10px; overflow:hidden; }
    th, td { border:1px solid #ddd; padding:8px; font-size:12px; text-align:center; white-space:nowrap; }
    th { background:#f8f9fa; position:sticky; top:0; }
    .dual { display:flex; gap:12px; flex-wrap:wrap; margin-top:10px; }
    .col { flex:1; min-width:260px; }
    .selectbox { width:100%; min-height:240px; }
    .midcol { min-width:120px; display:flex; flex-direction:column; gap:10px; justify-content:center; }
    .box-note { border:1px dashed #ddd; border-radius:10px; padding:10px; background:#fafafa; }
  </style>
</head>
<body>
  <h1>Kinase Interaction Heatmap Tool</h1>

  <div class="panel">
    <h2>1. 資料載入（KLIFS-only 與 Docking Compare 分離）</h2>
    <div class="muted">
      <b>KLIFS-only heatmap</b> 只需要： (A) <b>KLIFS_export.csv</b> + (B) <b>KLIFS IFP xlsx</b><br/>
      <b>Docking Compare</b> 才需要： (C) <b>alignment xlsx</b> + (D) <b>Docking pose xlsx</b><br/>
      為避免順序錯誤：依賴未滿足時，上傳欄位會自動灰階不可點。
    </div>

    <div class="flex-row" style="margin-top:10px;">
      <div class="field">
        <label>(A) 上傳 KLIFS_export.csv（NAME / FAMILY / GROUPS）</label>
        <input type="file" id="metaCsvInput" accept=".csv,.tsv,text/csv,text/tab-separated-values" />
      </div>
      <div class="field">
        <label>(B) 上傳 KLIFS IFP xlsx</label>
        <input type="file" id="klifsIfpInput" accept=".xlsx" disabled />
      </div>
      <div class="field">
        <label>(C) 上傳 alignment xlsx（KLIFS_done）</label>
        <input type="file" id="alignXlsxInput" accept=".xlsx" disabled />
      </div>
      <div class="field">
        <label>(D) 上傳 Docking pose xlsx（原始 Glide pose table）</label>
        <input type="file" id="dockXlsxInput" accept=".xlsx" disabled />
      </div>
      <div class="field" style="min-width:360px;">
        <label>Docking kinase 名稱（用來自動 align + scope）</label>
        <input type="text" id="dockKinaseInput" placeholder="例如：CLK4" disabled />
        <div class="muted small">Compare 不再手選 KLIFS_ID；由此名稱自動配對 alignment row。</div>
      </div>
      <div class="field">
        <label>狀態</label>
        <div class="status" id="statusText">初始化：請先上傳 KLIFS_export.csv</div>
      </div>
    </div>

    <div class="flex-row" style="margin-top:10px;">
      <div class="field" style="min-width:300px;">
        <label>Heatmap 顯示層級</label>
        <select id="viewModeSelect" disabled>
          <option value="kinase">Kinase</option>
          <option value="family">Family 平均</option>
          <option value="group">Group 平均</option>
        </select>
      </div>

      <div class="field" style="min-width:320px;">
        <label>Feature x 軸顯示模式</label>
        <select id="featureLabelMode" disabled>
          <option value="auto">Auto（有 docking+alignment+kinase → 顯示 residue；否則 KLIFS 1–85）</option>
          <option value="klifs">強制 KLIFS 1–85（例如 12-HB）</option>
          <option value="residue">強制 residue number（例如 167-HB；需要 docking+alignment+kinase）</option>
        </select>
      </div>

      <div class="field">
        <button id="runKlifsHeatmapBtn" disabled>更新 KLIFS Heatmap</button>
      </div>
      <div class="field">
        <button id="compareBtn" disabled>Compare（Docking vs KLIFS）</button>
      </div>

      <div class="field" style="min-width:520px;">
        <div class="muted" id="loadInfo"></div>
      </div>
    </div>
  </div>

  <div class="panel">
    <h2>2. 篩選（只影響 KLIFS 區塊）</h2>
    <div class="box-note muted">
      規則：<br/>
      • viewMode= <b>kinase</b>：可以用 Family/Group 篩選 + 自選 kinase 清單<br/>
      • viewMode= <b>family</b>：只允許選擇「顯示哪個 family」<br/>
      • viewMode= <b>group</b>：只允許選擇「顯示哪個 group」
    </div>

    <div class="flex-row" style="margin-top:10px;">
      <div class="field">
        <label>選擇顯示 Family（僅 family view）</label>
        <select id="singleFamilySelect" disabled><option value="">（尚未載入）</option></select>
      </div>
      <div class="field">
        <label>選擇顯示 Group（僅 group view）</label>
        <select id="singleGroupSelect" disabled><option value="">（尚未載入）</option></select>
      </div>
    </div>

    <div id="kinaseModeBlock" style="margin-top:10px;">
      <div class="flex-row">
        <div class="field">
          <label>Family 篩選（kinase view）</label>
          <select id="familyFilter" disabled><option value="">全部 Family</option></select>
        </div>
        <div class="field">
          <label>Group 篩選（kinase view）</label>
          <select id="groupFilter" disabled><option value="">全部 Group</option></select>
        </div>
        <div class="field" style="flex:1; min-width:260px;">
          <label>搜尋 kinase（影響左側待選）</label>
          <input type="text" id="kinaseSearch" placeholder="輸入關鍵字..." disabled />
        </div>
      </div>

      <div class="dual">
        <div class="col">
          <label>待選清單</label>
          <select id="availableKinases" class="selectbox" multiple disabled></select>
        </div>
        <div class="midcol">
          <button id="addKinaseBtn" disabled>➔</button>
          <button id="removeKinaseBtn" disabled>⬅</button>
          <div class="muted small">也可雙擊移動</div>
        </div>
        <div class="col">
          <label>已選清單（heatmap y 軸）</label>
          <select id="selectedKinases" class="selectbox" multiple disabled></select>
        </div>
      </div>
      <div class="muted small" style="margin-top:6px;">
        說明：已選清單為空 → 視為「全部 kinase」（再套 family/group 篩選）。
      </div>
    </div>
  </div>

  <div class="panel">
    <h2>3. 結果</h2>
    <div class="muted" id="summaryInfo"></div>

    <h3 style="margin-top:12px;">(KLIFS-only) Heatmap</h3>
    <div class="muted small">
      不需要 docking / alignment 也能跑。若你已上傳 docking+alignment 且 featureLabelMode=Auto/Residue，橫軸會顯示「真正 residue 序列」。
    </div>
    <div id="heatmap"></div>

    <hr />

    <h3>(Docking Compare) 差異圖：Docking freq（bar）＋ KLIFS freq（line）＋ Diff（line, y2）</h3>
    <div class="muted small">
      KLIFS freq 的 scope：依 docking kinase 所屬 family/group + 目前 viewMode 自動決定。<br/>
      例：dock=CLK4 且 viewMode=group → KLIFS freq = CMGC 平均。
    </div>
    <div id="diffPlot"></div>

    <hr />

    <h3>(Docking Compare) 全局指標：Jaccard / PERMANOVA / best-match + MDS</h3>
    <div class="muted small">
      KLIFS 點集同樣使用上述 scope（不移除低頻 interaction）。
    </div>
    <div id="mdsPlot"></div>
  </div>

  <div class="panel">
    <h2>4. Unknown group/unknown meta 名單與近似比對匯出（暫時功能）</h2>
    <div class="muted">
      這裡列出「KLIFS IFP 中出現，但在 KLIFS_export.csv 內找不到匹配」的 kinase。<br/>
      並用 normalize（大小寫、括號、符號）+ Levenshtein 找最相似的 meta NAME，輸出 xlsx 供你人工修正 mapping 規則。
    </div>
    <div class="flex-row" style="margin-top:10px;">
      <button id="exportUnknownBtn" disabled>匯出 Unknown kinases 近似比對結果 (XLSX)</button>
      <div class="muted small" id="unknownInfo"></div>
    </div>
  </div>

<script>
/* ===========================
   0) Global + DOM
   =========================== */

const statusText = document.getElementById("statusText");
const loadInfo = document.getElementById("loadInfo");

const metaCsvInput = document.getElementById("metaCsvInput");
const klifsIfpInput = document.getElementById("klifsIfpInput");
const alignXlsxInput = document.getElementById("alignXlsxInput");
const dockXlsxInput = document.getElementById("dockXlsxInput");
const dockKinaseInput = document.getElementById("dockKinaseInput");

const viewModeSelect = document.getElementById("viewModeSelect");
const featureLabelModeSelect = document.getElementById("featureLabelMode");

const runKlifsHeatmapBtn = document.getElementById("runKlifsHeatmapBtn");
const compareBtn = document.getElementById("compareBtn");

const singleFamilySelect = document.getElementById("singleFamilySelect");
const singleGroupSelect = document.getElementById("singleGroupSelect");

const familyFilterSelect = document.getElementById("familyFilter");
const groupFilterSelect = document.getElementById("groupFilter");
const kinaseSearchInput = document.getElementById("kinaseSearch");
const availableKinasesSelect = document.getElementById("availableKinases");
const selectedKinasesSelect = document.getElementById("selectedKinases");
const addKinaseBtn = document.getElementById("addKinaseBtn");
const removeKinaseBtn = document.getElementById("removeKinaseBtn");

const summaryInfo = document.getElementById("summaryInfo");
const exportUnknownBtn = document.getElementById("exportUnknownBtn");
const unknownInfo = document.getElementById("unknownInfo");

const kinaseKeyName = "kinase";

// load flags
let metaLoaded=false, klifsLoaded=false, alignLoaded=false, dockLoaded=false;

// meta
let metaRowsRaw=[]; // {NAME,FAMILY,GROUPS}
let metaNormToRow = new Map();
let familyList=[], groupList=[];

// KLIFS IFP
let klifsRaw2D=null;
let klifsFeatureKeys=[];        // "1-HP","1-HB"..."85-HP","85-HB"
let klifsKinaseFreqRows=[];     // per-kinase freq %
let klifsStructBinaryRows=[];   // per-structure 0/1
let allKinaseNames=[];

// alignment
let alignmentMapById = new Map(); // structure_ID -> {pos->res}
let alignmentIds=[];

// docking
let dockRaw2D=null;
let dockBinaryRows=[];
let dockFreqRow=null;

// current view
let viewMode="kinase";
let featureLabelMode="auto";

/* ===========================
   1) Utilities (safe + IO)
   =========================== */
function setStatus(msg){ statusText.textContent = msg; }
function safeTrim(v){ return (v==null) ? "" : String(v).trim(); }

function readXlsxArrayBuffer(buffer){
  const data = new Uint8Array(buffer);
  const wb = XLSX.read(data, { type:"array" });
  const ws = wb.Sheets[wb.SheetNames[0]];
  return XLSX.utils.sheet_to_json(ws, { header:1, raw:true, defval:null });
}

function parseCsvLoose(text){
  const lines = text.split(/\r?\n/).filter(l => l.trim() !== "");
  if (lines.length < 2) return { header:[], rows:[] };

  const split = (line) => {
    // choose delimiter by count
    const c = line.split(",");
    const t = line.split("\t");
    const parts = (t.length > c.length) ? t : c;
    return parts.map(x => x.trim());
  };

  const header = split(lines[0]);
  const rows = [];
  for (let i=1; i<lines.length; i++) rows.push(split(lines[i]));
  return { header, rows };
}

function findCol(header, candidates){
  const lower = header.map(h => safeTrim(h).toLowerCase());
  for (const cand of candidates){
    const idx = lower.indexOf(String(cand).toLowerCase());
    if (idx >= 0) return idx;
  }
  return -1;
}

/* ===========================
   2) Name normalization + fuzzy
   =========================== */
function normalizeNameBasic(s){
  const up = safeTrim(s).toUpperCase();
  const noParen = up.replace(/\(.*?\)/g, " ");
  return noParen.replace(/[^A-Z0-9]+/g, "");
}
function normalizeNameKeepParenAliases(s){
  const raw = safeTrim(s);
  const m = raw.match(/^(.*?)\((.*?)\)\s*$/);
  if (!m) return { primary: normalizeNameBasic(raw), alias:"" };
  return { primary: normalizeNameBasic(m[1]), alias: normalizeNameBasic(m[2]) };
}
function levenshtein(a,b){
  const s=a||"", t=b||"";
  const n=s.length, m=t.length;
  if (!n) return m;
  if (!m) return n;
  const dp = Array.from({length:n+1}, ()=>Array(m+1).fill(0));
  for (let i=0;i<=n;i++) dp[i][0]=i;
  for (let j=0;j<=m;j++) dp[0][j]=j;
  for (let i=1;i<=n;i++){
    for (let j=1;j<=m;j++){
      const cost = (s[i-1]===t[j-1])?0:1;
      dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost);
    }
  }
  return dp[n][m];
}
function similarityScore(a,b){
  if (!a || !b) return 0;
  const d = levenshtein(a,b);
  const denom = Math.max(a.length,b.length) || 1;
  return 1 - d/denom;
}
function lookupMetaForKinase(kinaseName){
  const nk = normalizeNameBasic(kinaseName);
  let row = metaNormToRow.get(nk);
  if (row) return { matched:true, FAMILY: row.FAMILY||"", GROUPS: row.GROUPS||"" };

  const parts = normalizeNameKeepParenAliases(kinaseName);
  row = metaNormToRow.get(parts.primary) || metaNormToRow.get(parts.alias);
  if (row) return { matched:true, FAMILY: row.FAMILY||"", GROUPS: row.GROUPS||"" };

  return { matched:false, FAMILY:"", GROUPS:"" };
}

/* ===========================
   3) UI locking (input order)
   =========================== */
function refreshUiLocks(){
  klifsIfpInput.disabled = !metaLoaded;

  const coreReady = metaLoaded && klifsLoaded;
  alignXlsxInput.disabled = !coreReady;
  dockXlsxInput.disabled  = !coreReady;
  dockKinaseInput.disabled = !coreReady;

  viewModeSelect.disabled = !coreReady;
  featureLabelModeSelect.disabled = !coreReady;
  runKlifsHeatmapBtn.disabled = !coreReady;

  // selection UI by viewMode
  viewMode = viewModeSelect.value || "kinase";
  document.getElementById("kinaseModeBlock").style.display = (viewMode==="kinase") ? "block" : "none";
  singleFamilySelect.disabled = !(coreReady && viewMode==="family");
  singleGroupSelect.disabled  = !(coreReady && viewMode==="group");

  const kinaseModeEnabled = coreReady && viewMode==="kinase";
  familyFilterSelect.disabled = !kinaseModeEnabled;
  groupFilterSelect.disabled  = !kinaseModeEnabled;
  kinaseSearchInput.disabled  = !kinaseModeEnabled;
  availableKinasesSelect.disabled = !kinaseModeEnabled;
  selectedKinasesSelect.disabled  = !kinaseModeEnabled;
  addKinaseBtn.disabled = !kinaseModeEnabled;
  removeKinaseBtn.disabled = !kinaseModeEnabled;

  exportUnknownBtn.disabled = !coreReady;

  // compare requires all + docking kinase non-empty
  const compareReady =
    coreReady &&
    alignLoaded &&
    dockLoaded &&
    safeTrim(dockKinaseInput.value) !== "";
  compareBtn.disabled = !compareReady;

  // status line
  loadInfo.innerHTML =
    `Meta: <span class="pill">${metaLoaded?"OK":"Missing"}</span> ` +
    `KLIFS IFP: <span class="pill">${klifsLoaded?"OK":"Missing"}</span> ` +
    `Alignment: <span class="pill">${alignLoaded?"OK":"Optional"}</span> ` +
    `Docking: <span class="pill">${dockLoaded?"OK":"Optional"}</span>`;
}

/* ===========================
   4) Load meta CSV (case-insensitive header)
   =========================== */
function parseMetaCsv(text){
  const { header, rows } = parseCsvLoose(text);
  const idxName   = findCol(header, ["name","NAME"]);
  const idxFamily = findCol(header, ["family","FAMILY"]);
  const idxGroup  = findCol(header, ["groups","group","GROUPS","GROUP"]);

  if (idxName<0 || idxFamily<0 || idxGroup<0){
    throw new Error("KLIFS_export.csv 需要包含欄位：NAME / FAMILY / GROUPS（大小寫可不同）");
  }

  metaRowsRaw = [];
  metaNormToRow = new Map();
  const famSet = new Set();
  const grpSet = new Set();

  for (const r of rows){
    if (!r || r.length <= Math.max(idxName, idxFamily, idxGroup)) continue;
    const NAME = safeTrim(r[idxName]);
    if (!NAME) continue;
    const FAMILY = safeTrim(r[idxFamily]);
    const GROUPS = safeTrim(r[idxGroup]);
    const rowObj = { NAME, FAMILY, GROUPS };
    metaRowsRaw.push(rowObj);

    const parts = normalizeNameKeepParenAliases(NAME);
    if (parts.primary) metaNormToRow.set(parts.primary, rowObj);
    if (parts.alias) metaNormToRow.set(parts.alias, rowObj);

    if (FAMILY) famSet.add(FAMILY);
    if (GROUPS) grpSet.add(GROUPS);
  }

  familyList = Array.from(famSet).sort();
  groupList = Array.from(grpSet).sort();

  // fill selects
  familyFilterSelect.innerHTML = `<option value="">全部 Family</option>`;
  familyList.forEach(f=>{
    const o=document.createElement("option"); o.value=f; o.textContent=f; familyFilterSelect.appendChild(o);
  });
  groupFilterSelect.innerHTML = `<option value="">全部 Group</option>`;
  groupList.forEach(g=>{
    const o=document.createElement("option"); o.value=g; o.textContent=g; groupFilterSelect.appendChild(o);
  });

  singleFamilySelect.innerHTML = `<option value="">請選擇 Family</option>`;
  familyList.forEach(f=>{
    const o=document.createElement("option"); o.value=f; o.textContent=f; singleFamilySelect.appendChild(o);
  });
  singleGroupSelect.innerHTML = `<option value="">請選擇 Group</option>`;
  groupList.forEach(g=>{
    const o=document.createElement("option"); o.value=g; o.textContent=g; singleGroupSelect.appendChild(o);
  });
}

metaCsvInput.addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;
  try{
    setStatus("載入 KLIFS_export.csv 中...");
    const text = await file.text();
    parseMetaCsv(text);
    metaLoaded = true;
    setStatus("KLIFS_export.csv 載入完成（請上傳 KLIFS IFP xlsx）");
  }catch(err){
    console.error(err);
    metaLoaded=false;
    setStatus("KLIFS_export.csv 載入失敗：" + err.message);
  }finally{
    refreshUiLocks();
  }
});

/* ===========================
   5) Load KLIFS IFP xlsx -> HP/HB
   =========================== */
// Expected layout: row0 header, row1 position, row2 IFP_type, row3 IFP_name, row4 Type, row5+ data
const positionRowIndex = 1;
const ifpTypeRowIndex  = 2;
const metaRowsCount    = 5;

function detectIfpColumnsFromHeader(data2D){
  const header = data2D?.[0] || [];
  const idx=[];
  for (let c=0;c<header.length;c++){
    const name = safeTrim(header[c]);
    if (/^IFP_/i.test(name)) idx.push(c);
  }
  idx.sort((a,b)=>a-b);
  return idx;
}

function collapseKlifsToHpHb(data2D, nMetaCols, ifpCols){
  const headerRow = data2D[0] || [];
  const positionRow = data2D[positionRowIndex] || [];
  const ifpTypeRow = data2D[ifpTypeRowIndex] || [];

  const hpTypes = new Set([1,2,3]);
  const hbTypes = new Set([4,5,6,7]);

  const posToHpCols = {};
  const posToHbCols = {};

  for (const colIdx of ifpCols){
    const pos = positionRow[colIdx];
    const t = ifpTypeRow[colIdx];
    if (pos==null || t==null || pos==="" || t==="") continue;
    const posInt = parseInt(pos,10);
    const tInt = parseInt(t,10);
    if (!Number.isFinite(posInt) || !Number.isFinite(tInt)) continue;
    if (!posToHpCols[posInt]) posToHpCols[posInt]=[];
    if (!posToHbCols[posInt]) posToHbCols[posInt]=[];
    if (hpTypes.has(tInt)) posToHpCols[posInt].push(colIdx);
    else if (hbTypes.has(tInt)) posToHbCols[posInt].push(colIdx);
  }

  const allPos0 = Array.from(new Set([
    ...Object.keys(posToHpCols).map(Number),
    ...Object.keys(posToHbCols).map(Number),
  ])).sort((a,b)=>a-b);

  // meta keys
  const metaKeys=[];
  for (let c=0;c<nMetaCols;c++){
    const name = safeTrim(headerRow[c]);
    if (!name) continue;
    metaKeys.push({idx:c, name});
  }

  const structRows=[];
  for (let r=metaRowsCount; r<data2D.length; r++){
    const row = data2D[r];
    if (!row || row.every(v=>v==null || String(v).trim()==="")) continue;

    const obj={};
    for (const mk of metaKeys) obj[mk.name] = row[mk.idx];

    for (const pos0 of allPos0){
      const hpCols = posToHpCols[pos0] || [];
      const hbCols = posToHbCols[pos0] || [];
      let hp=0, hb=0;
      for (const idx of hpCols){ const v=Number(row[idx]); if (Number.isFinite(v) && v>0){ hp=1; break; } }
      for (const idx of hbCols){ const v=Number(row[idx]); if (Number.isFinite(v) && v>0){ hb=1; break; } }
      const p = pos0 + 1;
      obj[`${p}-HP`] = hp;
      obj[`${p}-HB`] = hb;
    }
    structRows.push(obj);
  }

  const featureKeys=[];
  for (const pos0 of allPos0){
    const p=pos0+1;
    featureKeys.push(`${p}-HP`, `${p}-HB`);
  }
  return { structRows, featureKeys };
}

function computeKinaseFreqAndStructBinary(structRows, featureKeys, kinaseColName, structureColName){
  const groups = new Map();
  const structBinary = [];

  for (const r of structRows){
    const k = r[kinaseColName];
    if (!k) continue;
    if (!groups.has(k)) groups.set(k, []);
    groups.get(k).push(r);

    const bin = {};
    bin[kinaseKeyName] = k;
    bin.structure_ID = r[structureColName];
    for (const f of featureKeys) bin[f] = Number(r[f]) ? 1 : 0;
    structBinary.push(bin);
  }

  const kinases = Array.from(groups.keys()).sort((a,b)=>String(a).localeCompare(String(b)));
  const freqRows = [];

  for (const k of kinases){
    const rows = groups.get(k);
    const out = {};
    out[kinaseKeyName]=k;
    out.__n = rows.length;
    out.__label = `${k} (n=${rows.length})`;
    for (const f of featureKeys){
      let sum=0;
      for (const r of rows) sum += Number(r[f]) ? 1 : 0;
      out[f] = rows.length ? (sum/rows.length)*100 : 0;
    }
    freqRows.push(out);
  }

  return { kinases, freqRows, structBinary };
}

function fillKinaseDualLists(kinaseList){
  availableKinasesSelect.innerHTML = "";
  selectedKinasesSelect.innerHTML = "";
  kinaseList.forEach(k=>{
    const o=document.createElement("option"); o.value=k; o.textContent=k; availableKinasesSelect.appendChild(o);
  });
}

klifsIfpInput.addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;
  try{
    setStatus("載入 KLIFS IFP xlsx 中...");
    const buffer = await file.arrayBuffer();
    klifsRaw2D = readXlsxArrayBuffer(buffer);

    const header = (klifsRaw2D[0] || []).map(safeTrim);
    const ifpCols = detectIfpColumnsFromHeader(klifsRaw2D);
    if (!ifpCols.length) throw new Error("找不到 IFP_ 欄位（header 需有 IFP_0, IFP_1...）");

    const kinaseIdx = findCol(header, ["kinase"]);
    const structureIdx = findCol(header, ["structure_id","structure id","structureid"]);
    if (kinaseIdx<0) throw new Error("KLIFS IFP 需包含 'kinase' 欄位");
    if (structureIdx<0) throw new Error("KLIFS IFP 需包含 'structure_ID' 欄位（連結 alignment）");

    // meta cols: until pdb if exists else minimum = max(structureIdx, kinaseIdx)+1
    let pdbIdx = findCol(header, ["pdb"]);
    if (pdbIdx < 0) pdbIdx = Math.max(structureIdx, kinaseIdx);
    const nMetaCols = Math.max(pdbIdx + 1, 4);

    const build = collapseKlifsToHpHb(klifsRaw2D, nMetaCols, ifpCols);
    klifsFeatureKeys = build.featureKeys.slice();

    // normalize standard keys
    const structRows = build.structRows.map(r=>{
      const out = { ...r };
      out[kinaseKeyName] = r[header[kinaseIdx]];
      out.structure_ID = r[header[structureIdx]];
      return out;
    });

    const calc = computeKinaseFreqAndStructBinary(structRows, klifsFeatureKeys, kinaseKeyName, "structure_ID");
    allKinaseNames = calc.kinases.slice();
    klifsKinaseFreqRows = calc.freqRows.slice();
    klifsStructBinaryRows = calc.structBinary.slice();

    fillKinaseDualLists(allKinaseNames);

    klifsLoaded = true;
    setStatus("KLIFS IFP 載入完成（可跑 KLIFS-only heatmap；可選擇是否上傳 alignment/docking）");

    updateUnknownInfo();

  }catch(err){
    console.error(err);
    klifsLoaded=false;
    setStatus("KLIFS IFP 載入失敗：" + err.message);
  }finally{
    refreshUiLocks();
  }
});

/* ===========================
   6) Alignment load
   =========================== */
function parseAlignmentXlsx(data2D){
  if (!data2D || data2D.length < 2) throw new Error("alignment xlsx 內容太少");
  const header = (data2D[0] || []).map(safeTrim);

  // col 0 = KLIFS structure_ID, col 1..85 = KLIFS position
  const posColIdx = new Map();
  for (let c=1; c<header.length; c++){
    const p = parseInt(header[c],10);
    if (Number.isFinite(p) && p>=1 && p<=85) posColIdx.set(p,c);
  }
  if (posColIdx.size < 10) throw new Error("alignment header 必須包含 1..85 欄位（首行）");

  alignmentMapById = new Map();
  alignmentIds = [];

  for (let r=1; r<data2D.length; r++){
    const row = data2D[r];
    if (!row || row.every(v=>v==null || String(v).trim()==="")) continue;

    const id = safeTrim(row[0]);
    if (!id) continue;

    const map = {};
    for (let p=1; p<=85; p++){
      const c = posColIdx.get(p);
      const valStr = c==null ? "" : safeTrim(row[c]);
      if (!valStr || valStr === "_" || valStr === "-") { map[p]=null; continue; }
      const n = parseInt(valStr,10);
      map[p] = Number.isFinite(n) ? n : null;
    }

    alignmentMapById.set(id, map);
    alignmentIds.push(id);
  }

  alignmentIds.sort((a,b)=>String(a).localeCompare(String(b)));
  return alignmentIds.length;
}

alignXlsxInput.addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;
  try{
    setStatus("載入 alignment xlsx 中...");
    const buffer = await file.arrayBuffer();
    const data2D = readXlsxArrayBuffer(buffer);
    const n = parseAlignmentXlsx(data2D);
    alignLoaded = true;
    setStatus(`alignment 載入完成（rows=${n}）`);
  }catch(err){
    console.error(err);
    alignLoaded=false;
    setStatus("alignment 載入失敗：" + err.message);
  }finally{
    refreshUiLocks();
  }
});

/* ===========================
   7) Docking load (raw)
   =========================== */
dockXlsxInput.addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;
  try{
    setStatus("載入 Docking pose xlsx 中...");
    const buffer = await file.arrayBuffer();
    dockRaw2D = readXlsxArrayBuffer(buffer);
    dockLoaded = true;
    setStatus("Docking pose 載入完成（請輸入 docking kinase，並上傳 alignment 後 Compare）");
  }catch(err){
    console.error(err);
    dockLoaded=false;
    setStatus("Docking pose 載入失敗：" + err.message);
  }finally{
    refreshUiLocks();
  }
});

dockKinaseInput.addEventListener("input", ()=>refreshUiLocks());

/* ===========================
   8) Dual list behavior
   =========================== */
function getSelectedKinases(){
  return Array.from(selectedKinasesSelect.options).map(o=>o.value);
}
function moveSelected(fromSel, toSel){
  const opts = Array.from(fromSel.selectedOptions);
  for (const opt of opts){
    const exists = Array.from(toSel.options).some(o=>o.value===opt.value);
    if (!exists){
      const n=document.createElement("option");
      n.value=opt.value; n.textContent=opt.textContent;
      toSel.appendChild(n);
    }
    fromSel.removeChild(opt);
  }
}
addKinaseBtn.addEventListener("click", ()=>moveSelected(availableKinasesSelect, selectedKinasesSelect));
removeKinaseBtn.addEventListener("click", ()=>moveSelected(selectedKinasesSelect, availableKinasesSelect));
availableKinasesSelect.addEventListener("dblclick", ()=>moveSelected(availableKinasesSelect, selectedKinasesSelect));
selectedKinasesSelect.addEventListener("dblclick", ()=>moveSelected(selectedKinasesSelect, availableKinasesSelect));

kinaseSearchInput.addEventListener("input", ()=>{
  const q = safeTrim(kinaseSearchInput.value).toLowerCase();
  const selectedSet = new Set(getSelectedKinases());
  availableKinasesSelect.innerHTML="";
  allKinaseNames
    .filter(k=>!selectedSet.has(k))
    .filter(k=>k.toLowerCase().includes(q))
    .forEach(k=>{
      const o=document.createElement("option"); o.value=k; o.textContent=k; availableKinasesSelect.appendChild(o);
    });
});

/* ===========================
   9) KLIFS heatmap rows by viewMode
   =========================== */
function aggregateFreqRowsByScope(scope, value){
  const key = scope==="family" ? "FAMILY" : "GROUPS";
  const rows = klifsKinaseFreqRows.filter(r=>{
    const meta = lookupMetaForKinase(r[kinaseKeyName]);
    return meta[key] === value;
  });

  const out={};
  out[kinaseKeyName]=value;
  const nKinase = rows.length;
  const nStruct = rows.reduce((acc,r)=>acc+(Number(r.__n)||0),0);
  out.__n = nStruct;
  out.__label = `${value} (nKinase=${nKinase}, nStruct=${nStruct})`;

  for (const f of klifsFeatureKeys){
    let sum=0, count=0;
    for (const r of rows){
      const v=Number(r[f]);
      if (Number.isFinite(v)){ sum+=v; count++; }
    }
    out[f] = count ? (sum/count) : 0;
  }
  return out;
}

function getKlifsHeatmapRows(){
  viewMode = viewModeSelect.value || "kinase";

  if (viewMode==="kinase"){
    const selected = getSelectedKinases();
    const fam = familyFilterSelect.value;
    const grp = groupFilterSelect.value;

    let base = selected.length ? klifsKinaseFreqRows.filter(r=>selected.includes(r[kinaseKeyName])) : klifsKinaseFreqRows.slice();
    base = base.filter(r=>{
      const meta = lookupMetaForKinase(r[kinaseKeyName]);
      if (fam && meta.FAMILY !== fam) return false;
      if (grp && meta.GROUPS !== grp) return false;
      return true;
    });
    return base;
  }

  if (viewMode==="family"){
    const fam = singleFamilySelect.value;
    if (!fam) return [];
    return [aggregateFreqRowsByScope("family", fam)];
  }

  if (viewMode==="group"){
    const grp = singleGroupSelect.value;
    if (!grp) return [];
    return [aggregateFreqRowsByScope("group", grp)];
  }

  return [];
}

/* ===========================
   10) Feature label mapping (KLIFS vs residue)
   =========================== */
function autoPickAlignmentStructureIdForDockingKinase(dk){
  // from KLIFS IFP: find any structure_ID for that kinase, then check alignment has it
  const k = safeTrim(dk);
  if (!k) return "";
  const candidates=[];
  for (const r of klifsStructBinaryRows){
    if (safeTrim(r[kinaseKeyName]) === k){
      const sid = safeTrim(r.structure_ID);
      if (sid) candidates.push(sid);
    }
  }
  for (const sid of candidates){
    if (alignmentMapById.has(sid)) return sid;
  }
  return "";
}

function buildResidueMapsByStructureId(structureId){
  const rowMap = alignmentMapById.get(structureId);
  const resToKlifs = new Map();
  const klifsToRes = new Map();
  if (!rowMap) return { resToKlifs, klifsToRes };

  for (let p=1; p<=85; p++){
    const res = rowMap[p];
    if (res==null) continue;
    klifsToRes.set(p, res);
    if (!resToKlifs.has(res)) resToKlifs.set(res, p);
  }
  return { resToKlifs, klifsToRes };
}

function buildFeatureDisplayMap(){
  featureLabelMode = featureLabelModeSelect.value || "auto";

  const map = new Map();
  for (const f of klifsFeatureKeys) map.set(f, f);

  const wantResidue =
    featureLabelMode==="residue" ||
    (featureLabelMode==="auto" && alignLoaded && dockLoaded && safeTrim(dockKinaseInput.value)!=="");

  if (!wantResidue) return map;

  const dk = safeTrim(dockKinaseInput.value);
  const sid = autoPickAlignmentStructureIdForDockingKinase(dk);
  if (!sid) return map;

  const { klifsToRes } = buildResidueMapsByStructureId(sid);
  if (!klifsToRes.size) return map;

  for (const f of klifsFeatureKeys){
    const m = String(f).match(/^(\d+)\-(HP|HB)$/i);
    if (!m) continue;
    const pos = parseInt(m[1],10);
    const kind = m[2].toUpperCase();
    const res = klifsToRes.get(pos);
    if (res) map.set(f, `${res}-${kind}`);
  }
  return map;
}

/* ===========================
   11) Plotly: Heatmap
   =========================== */
function drawHeatmap(rows, featureDisplayMap, title){
  if (!rows.length){
    Plotly.purge("heatmap");
    summaryInfo.innerHTML = `<span class="danger">目前條件下沒有可顯示的 rows。</span>`;
    return;
  }

  const x = klifsFeatureKeys.map(f=>featureDisplayMap.get(f) || f);
  const y = rows.map(r=>r.__label ?? r[kinaseKeyName] ?? "row");
  const z = rows.map(r=>klifsFeatureKeys.map(f=>{
    const v=Number(r[f]);
    return Number.isFinite(v) ? v : 0;
  }));

  Plotly.newPlot("heatmap", [{
    x,y,z, type:"heatmap", colorscale:"Viridis", zmin:0,
    colorbar:{ title:"Frequency (%)" }
  }], {
    title,
    xaxis:{ title:"Features", tickangle:-90 },
    yaxis:{ title:"Rows" },
    margin:{ l:220, r:20, t:50, b:170 },
    height: Math.max(560, 28*rows.length + 240),
  }, { responsive:true });

  summaryInfo.innerHTML =
    `ViewMode：<span class="pill">${viewMode}</span>　` +
    `Rows：<span class="pill">${rows.length}</span>　` +
    `Features：<span class="pill">${klifsFeatureKeys.length}</span>　` +
    `X-label：<span class="pill">${featureLabelMode}</span>`;
}

runKlifsHeatmapBtn.addEventListener("click", ()=>{
  try{
    if (!(metaLoaded && klifsLoaded)) return;

    viewMode = viewModeSelect.value || "kinase";
    if (viewMode==="family" && !singleFamilySelect.value){
      alert("請先選擇要顯示的 Family。"); return;
    }
    if (viewMode==="group" && !singleGroupSelect.value){
      alert("請先選擇要顯示的 Group。"); return;
    }

    const rows = getKlifsHeatmapRows();
    const fmap = buildFeatureDisplayMap();
    drawHeatmap(rows, fmap, "KLIFS Interaction Frequency Heatmap (%)");

  }catch(err){
    console.error(err);
    alert("更新 heatmap 失敗：" + err.message);
  }
});

// reactive refresh
viewModeSelect.addEventListener("change", ()=>{ refreshUiLocks(); if (klifsLoaded) runKlifsHeatmapBtn.click(); });
featureLabelModeSelect.addEventListener("change", ()=>{ if (klifsLoaded) runKlifsHeatmapBtn.click(); });
singleFamilySelect.addEventListener("change", ()=>{ if (klifsLoaded) runKlifsHeatmapBtn.click(); });
singleGroupSelect.addEventListener("change", ()=>{ if (klifsLoaded) runKlifsHeatmapBtn.click(); });
familyFilterSelect.addEventListener("change", ()=>{ if (klifsLoaded) runKlifsHeatmapBtn.click(); });
groupFilterSelect.addEventListener("change", ()=>{ if (klifsLoaded) runKlifsHeatmapBtn.click(); });

/* ===========================
   12) Docking processing (auto align)
   =========================== */
const DOCK_KEYS = ["Pi-Hydrophobic","AlkylHydrophobic","MixedPiAlkylHydrophobic","HydrogenBond"];

function parseDockingInteractionColumn(colName){
  const s = String(colName||"");
  let kind=null;
  if (s.includes("HydrogenBond")) kind="HB";
  else if (s.includes("Pi-Hydrophobic") || s.includes("AlkylHydrophobic") || s.includes("MixedPiAlkylHydrophobic")) kind="HP";
  else return null;

  const m = s.match(/([A-Z]{3})(\d{1,5})/);
  if (!m) return null;
  const resNum = parseInt(m[2],10);
  if (!Number.isFinite(resNum)) return null;
  return { residueNumber: resNum, kind };
}

function processDockingPoseTable(data2D, sid){
  const header = (data2D[0] || []).map(safeTrim);
  const nameIdx = findCol(header, ["name"]);
  if (nameIdx<0) throw new Error("Docking 檔需包含 Name 欄位");
  const dsIdx = findCol(header, ["r_i_docking_score","docking_score"]);

  const interactionCols=[];
  for (let c=0;c<header.length;c++){
    const h=header[c];
    if (!h) continue;
    if (DOCK_KEYS.some(k=>h.includes(k))){
      const p = parseDockingInteractionColumn(h);
      if (p) interactionCols.push({ idx:c, ...p });
    }
  }
  if (!interactionCols.length) throw new Error("Docking 檔找不到 interaction 欄位（需含 HydrogenBond / Pi-Hydrophobic / AlkylHydrophobic / MixedPiAlkylHydrophobic）");

  const { resToKlifs } = buildResidueMapsByStructureId(sid);
  if (!resToKlifs.size) throw new Error("alignment row 無法建立 residue→KLIFS mapping（可能該 row 大多為 '_'）");

  const raw=[];
  for (let r=1;r<data2D.length;r++){
    const row=data2D[r];
    if (!row || row.every(v=>v==null || String(v).trim()==="")) continue;

    const name=safeTrim(row[nameIdx]);
    if (!name) continue;
    const ds = (dsIdx>=0) ? Number(row[dsIdx]) : NaN;

    const feat={};
    for (const ic of interactionCols){
      const val = Number(row[ic.idx]);
      const bin = Number.isFinite(val) && val >= 1 ? 1 : 0;
      if (!bin) continue;

      const klifsPos = resToKlifs.get(ic.residueNumber);
      if (!klifsPos) continue; // residue not mapped => ignore
      feat[`${klifsPos}-${ic.kind}`] = 1;
    }
    raw.push({ Name:name, DS:ds, feat });
  }
  if (!raw.length) throw new Error("Docking 檔沒有有效資料列");

  // dedup by Name keep best DS (lower)
  const best = new Map();
  for (const r of raw){
    if (!best.has(r.Name)) best.set(r.Name, r);
    else{
      const cur = best.get(r.Name);
      const curOk = Number.isFinite(cur.DS);
      const newOk = Number.isFinite(r.DS);
      if (!curOk && newOk) best.set(r.Name, r);
      else if (curOk && newOk && r.DS < cur.DS) best.set(r.Name, r);
    }
  }
  const uniq = Array.from(best.values());

  const featureSet = new Set(klifsFeatureKeys);
  const dockBinary = uniq.map(r=>{
    const out={ Name:r.Name, DS:r.DS };
    for (const f of featureSet) out[f]=0;
    for (const k of Object.keys(r.feat)){
      if (featureSet.has(k)) out[k]=1;
    }
    return out;
  });

  const freq={ __n:dockBinary.length, __label:`Docking (n=${dockBinary.length})` };
  for (const f of featureSet){
    let sum=0;
    for (const r of dockBinary) sum += Number(r[f]) ? 1 : 0;
    freq[f] = dockBinary.length ? (sum/dockBinary.length)*100 : 0;
  }

  return { dockBinary, freq };
}

/* ===========================
   13) Scope for Compare (dock kinase + viewMode)
   =========================== */
function getScopeForDockAndViewMode(){
  const dk = safeTrim(dockKinaseInput.value);
  const meta = lookupMetaForKinase(dk);
  const vm = viewModeSelect.value || "kinase";

  if (vm==="kinase") return { mode:"kinase", kinase:dk, family:meta.FAMILY, group:meta.GROUPS, metaMatched:meta.matched };
  if (vm==="family") return { mode:"family", kinase:dk, family:meta.FAMILY, group:meta.GROUPS, metaMatched:meta.matched };
  if (vm==="group")  return { mode:"group",  kinase:dk, family:meta.FAMILY, group:meta.GROUPS, metaMatched:meta.matched };
  return { mode:"kinase", kinase:dk, family:meta.FAMILY, group:meta.GROUPS, metaMatched:meta.matched };
}

function getKlifsFreqRowForScope(scope){
  if (scope.mode==="kinase"){
    const row = klifsKinaseFreqRows.find(r=>safeTrim(r[kinaseKeyName])===scope.kinase);
    return row || null;
  }
  if (scope.mode==="family"){
    if (!scope.family) return null;
    return aggregateFreqRowsByScope("family", scope.family);
  }
  if (scope.mode==="group"){
    if (!scope.group) return null;
    return aggregateFreqRowsByScope("group", scope.group);
  }
  return null;
}

function getKlifsStructBinaryForScope(scope){
  if (scope.mode==="kinase"){
    return klifsStructBinaryRows.filter(r=>safeTrim(r[kinaseKeyName])===scope.kinase);
  }
  if (scope.mode==="family"){
    return klifsStructBinaryRows.filter(r=>lookupMetaForKinase(r[kinaseKeyName]).FAMILY===scope.family);
  }
  if (scope.mode==="group"){
    return klifsStructBinaryRows.filter(r=>lookupMetaForKinase(r[kinaseKeyName]).GROUPS===scope.group);
  }
  return [];
}

/* ===========================
   14) Diff plot (Dock bar + KLIFS line + Diff y2)
   =========================== */
function drawDiffPlot(dockFreq, klifsFreq, fmap){
  if (!dockFreq || !klifsFreq){
    Plotly.purge("diffPlot");
    return;
  }

  const items = klifsFeatureKeys.map(f=>{
    const d = Number(dockFreq[f]) || 0;
    const k = Number(klifsFreq[f]) || 0;
    return { f, dock:d, klifs:k, diff:(d-k) };
  }).sort((a,b)=>b.dock - a.dock);

  const x = items.map(it=>fmap.get(it.f) || it.f);
  const yDock = items.map(it=>it.dock);
  const yKlifs = items.map(it=>it.klifs);
  const yDiff = items.map(it=>it.diff);

  Plotly.newPlot("diffPlot", [
    { x, y:yDock, type:"bar", name:"Docking freq (%)", yaxis:"y1" },
    { x, y:yKlifs, type:"scatter", mode:"lines+markers", name:"KLIFS freq (%)", yaxis:"y1" },
    { x, y:yDiff, type:"scatter", mode:"lines+markers", name:"Diff (Dock - KLIFS)", yaxis:"y2" }
  ], {
    title:"Docking vs KLIFS (Freq + Diff)",
    xaxis:{ tickangle:-90, title:"Features" },
    yaxis:{ title:"Frequency (%)" },
    yaxis2:{ title:"Diff (%)", overlaying:"y", side:"right" },
    margin:{ l:80, r:80, t:50, b:170 },
    height: 640,
    legend:{ orientation:"h" }
  }, { responsive:true });
}

/* ===========================
   15) Jaccard / PERMANOVA / MDS
   =========================== */
function jaccardDistance(a,b){
  let inter=0, uni=0;
  for (let i=0;i<a.length;i++){
    const ai=a[i]?1:0, bi=b[i]?1:0;
    if (ai||bi) uni++;
    if (ai&&bi) inter++;
  }
  if (!uni) return 0;
  return 1 - inter/uni;
}
function pairwiseDistanceMatrix(vectors){
  const n=vectors.length;
  const D=Array.from({length:n},()=>Array(n).fill(0));
  for (let i=0;i<n;i++){
    for (let j=i+1;j<n;j++){
      const d=jaccardDistance(vectors[i],vectors[j]);
      D[i][j]=d; D[j][i]=d;
    }
  }
  return D;
}
function permanovaTest(D, labels, nPerm=299){
  const n=labels.length;
  const uniq=Array.from(new Set(labels));

  function ssWithin(lbls){
    let ss=0;
    for (const g of uniq){
      const idx=[];
      for (let i=0;i<n;i++) if (lbls[i]===g) idx.push(i);
      if (idx.length<=1) continue;
      let sum=0;
      for (let a=0;a<idx.length;a++){
        for (let b=0;b<idx.length;b++){
          const d=D[idx[a]][idx[b]];
          sum += d*d;
        }
      }
      ss += sum / idx.length;
    }
    return ss;
  }
  function ssBetween(lbls){
    let sumAll=0;
    for (let i=0;i<n;i++){
      for (let j=0;j<n;j++){
        const d=D[i][j];
        sumAll += d*d;
      }
    }
    const grand = sumAll/(n*n);
    let ss=0;
    for (const g of uniq){
      const idx=[];
      for (let i=0;i<n;i++) if (lbls[i]===g) idx.push(i);
      if (!idx.length) continue;
      let sum=0;
      for (let a=0;a<idx.length;a++){
        for (let b=0;b<idx.length;b++){
          const d=D[idx[a]][idx[b]];
          sum += d*d;
        }
      }
      const mean = sum/(idx.length*idx.length);
      ss += idx.length*(mean-grand)*(mean-grand);
    }
    return ss;
  }

  const ssW=ssWithin(labels);
  const ssB=ssBetween(labels);
  const Fobs = ssB/(ssW+1e-12);

  let count=0;
  for (let p=0;p<nPerm;p++){
    const perm=labels.slice();
    for (let i=n-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [perm[i],perm[j]]=[perm[j],perm[i]];
    }
    const Fp = ssBetween(perm)/(ssWithin(perm)+1e-12);
    if (Fp>=Fobs) count++;
  }
  const pval=(count+1)/(nPerm+1);
  return { F:Fobs, p:pval };
}

function mds2DFromDistance(D){
  const n=D.length;
  const D2=Array.from({length:n},()=>Array(n).fill(0));
  for (let i=0;i<n;i++) for (let j=0;j<n;j++) D2[i][j]=D[i][j]*D[i][j];

  const rowMean=Array(n).fill(0), colMean=Array(n).fill(0);
  for (let i=0;i<n;i++){
    let s=0; for (let j=0;j<n;j++) s+=D2[i][j];
    rowMean[i]=s/n;
  }
  for (let j=0;j<n;j++){
    let s=0; for (let i=0;i<n;i++) s+=D2[i][j];
    colMean[j]=s/n;
  }
  const grand = rowMean.reduce((a,b)=>a+b,0)/n;

  const B=Array.from({length:n},()=>Array(n).fill(0));
  for (let i=0;i<n;i++){
    for (let j=0;j<n;j++){
      B[i][j] = -0.5*(D2[i][j]-rowMean[i]-colMean[j]+grand);
    }
  }

  function matVec(M,v){
    const out=Array(M.length).fill(0);
    for (let i=0;i<M.length;i++){
      let s=0; for (let j=0;j<M.length;j++) s+=M[i][j]*v[j];
      out[i]=s;
    }
    return out;
  }
  function dot(a,b){ let s=0; for (let i=0;i<a.length;i++) s+=a[i]*b[i]; return s; }
  function norm(a){ return Math.sqrt(dot(a,a)) || 1; }
  function scale(a,k){ return a.map(x=>x*k); }

  function powerIter(M, it=220){
    let v=Array(M.length).fill(0).map(()=>Math.random()-0.5);
    v=scale(v, 1/norm(v));
    for (let t=0;t<it;t++){
      const w=matVec(M,v);
      v=scale(w, 1/norm(w));
    }
    const w=matVec(M,v);
    const lambda=dot(v,w);
    return { lambda, v };
  }

  const e1=powerIter(B,260);
  const B2=Array.from({length:n},(_,i)=>Array.from({length:n},(_,j)=>B[i][j]-e1.lambda*e1.v[i]*e1.v[j]));
  const e2=powerIter(B2,260);

  const l1=Math.max(e1.lambda,0), l2=Math.max(e2.lambda,0);
  const x=e1.v.map(v=>v*Math.sqrt(l1));
  const y=e2.v.map(v=>v*Math.sqrt(l2));
  return { x,y };
}

function drawMds(vectors, labels){
  if (vectors.length < 3){
    Plotly.purge("mdsPlot");
    return { perma:null, note:"樣本數太少，無法計算 MDS/PERMANOVA（需至少 3）" };
  }
  const D = pairwiseDistanceMatrix(vectors);
  const perma = permanovaTest(D, labels, 299);
  const mds = mds2DFromDistance(D);

  const xK=[], yK=[], xD=[], yD=[];
  for (let i=0;i<labels.length;i++){
    if (labels[i]==="KLIFS"){ xK.push(mds.x[i]); yK.push(mds.y[i]); }
    else { xD.push(mds.x[i]); yD.push(mds.y[i]); }
  }

  Plotly.newPlot("mdsPlot", [
    { x:xK, y:yK, type:"scatter", mode:"markers", name:`KLIFS (n=${xK.length})`, opacity:0.45, marker:{ size:9, symbol:"triangle-up" } },
    { x:xD, y:yD, type:"scatter", mode:"markers", name:`Docking (n=${xD.length})`, opacity:0.85, marker:{ size:8 } }
  ], {
    title:"MDS (Jaccard distance)",
    xaxis:{ title:"Dim 1" },
    yaxis:{ title:"Dim 2" },
    margin:{ l:70, r:20, t:50, b:50 },
    height:620,
    legend:{ orientation:"h" }
  }, { responsive:true });

  return { perma };
}

/* ===========================
   16) Compare handler (auto align + scope)
   =========================== */
compareBtn.addEventListener("click", ()=>{
  try{
    if (!(metaLoaded && klifsLoaded && alignLoaded && dockLoaded)){
      alert("Compare 需要：meta + KLIFS IFP + alignment + docking 都已上傳。");
      return;
    }
    const dk = safeTrim(dockKinaseInput.value);
    if (!dk){ alert("請先輸入 docking kinase（例如 CLK4）。"); return; }

    const scope = getScopeForDockAndViewMode();
    if ((scope.mode==="family" && !scope.family) || (scope.mode==="group" && !scope.group)){
      alert("docking kinase 在 meta 找不到 family/group，因此無法依 viewMode 計算 scope 平均。你可先修正名稱或用 Unknown 匯出結果比對。");
      return;
    }

    // auto pick alignment row by docking kinase
    const sid = autoPickAlignmentStructureIdForDockingKinase(dk);
    if (!sid){
      alert("無法自動配對 alignment row。\n請確認：\n1) KLIFS IFP 中存在該 kinase 名稱\n2) alignment 第一欄的 KLIFS_ID(=structure_ID) 含該 kinase 的 structure_ID");
      return;
    }

    // docking -> binary & freq
    const proc = processDockingPoseTable(dockRaw2D, sid);
    dockBinaryRows = proc.dockBinary;
    dockFreqRow = proc.freq;

    // klifs freq (scope)
    const klifsFreq = getKlifsFreqRowForScope(scope);
    if (!klifsFreq){ alert("無法建立 KLIFS scope 平均（可能 family/group 為空）。"); return; }

    // feature label map MUST use docking alignment (你要求 group/family 也要顯示真正 residue)
    const fmap = new Map();
    for (const f of klifsFeatureKeys) fmap.set(f, f);

    // Always map to residue when compare (as long as sid provides mapping)
    const { klifsToRes } = buildResidueMapsByStructureId(sid);
    for (const f of klifsFeatureKeys){
      const m = String(f).match(/^(\d+)\-(HP|HB)$/i);
      if (!m) continue;
      const pos=parseInt(m[1],10);
      const kind=m[2].toUpperCase();
      const res=klifsToRes.get(pos);
      if (res) fmap.set(f, `${res}-${kind}`);
    }

    // Compare heatmap = KLIFS scope row (top) + Docking row (bottom)
    const klifsRowsForHeatmap = [];
    if (scope.mode==="kinase"){
      const row = klifsKinaseFreqRows.find(r=>safeTrim(r[kinaseKeyName])===dk);
      if (row) klifsRowsForHeatmap.push(row);
      else klifsRowsForHeatmap.push(klifsFreq); // fallback
    }else{
      klifsRowsForHeatmap.push(klifsFreq);
    }
    const combined = [...klifsRowsForHeatmap, dockFreqRow];
    drawHeatmap(combined, fmap, "KLIFS (scope) vs Docking (Compare Heatmap)");

    // Diff plot (must show KLIFS freq too)
    drawDiffPlot(dockFreqRow, klifsFreq, fmap);

    // MDS vectors: KLIFS structures in scope + docking ligands
    const klifsStruct = getKlifsStructBinaryForScope(scope);
    const klifsVec = klifsStruct.map(r=>klifsFeatureKeys.map(f=>Number(r[f])?1:0));
    const dockVec  = dockBinaryRows.map(r=>klifsFeatureKeys.map(f=>Number(r[f])?1:0));

    const vectors=[], labels=[];
    for (const v of klifsVec){ vectors.push(v); labels.push("KLIFS"); }
    for (const v of dockVec){ vectors.push(v); labels.push("Docking"); }

    const mdsRes = drawMds(vectors, labels);

    // best-match
    const bestMatch=[];
    for (let i=0;i<dockVec.length;i++){
      let best=-1;
      for (let j=0;j<klifsVec.length;j++){
        const sim = 1 - jaccardDistance(dockVec[i], klifsVec[j]);
        if (sim>best) best=sim;
      }
      bestMatch.push(best);
    }
    const bestMax = bestMatch.length ? Math.max(...bestMatch) : 0;
    const nGe095 = bestMatch.filter(x=>x>=0.95).length;

    const permaText = mdsRes.perma
      ? `PERMANOVA F=${mdsRes.perma.F.toFixed(4)}, p=${mdsRes.perma.p.toFixed(4)}`
      : (mdsRes.note || "PERMANOVA unavailable");

    summaryInfo.innerHTML =
      `Compare scope：<span class="pill">${scope.mode==="kinase" ? `kinase=${dk}` : (scope.mode==="family" ? `family=${scope.family}` : `group=${scope.group}`)}</span>　` +
      `Alignment row（auto）：<span class="pill">${sid}</span>　` +
      `Docking ligands：<span class="pill">${dockFreqRow.__n}</span>　` +
      `KLIFS structures：<span class="pill">${klifsStruct.length}</span><br/>` +
      `${permaText}　best-match max=<span class="pill">${bestMax.toFixed(4)}</span>　#dock≥0.95=<span class="pill">${nGe095}</span>`;

  }catch(err){
    console.error(err);
    alert("Compare 失敗：" + err.message);
  }
});

/* ===========================
   17) Unknown kinases export
   =========================== */
function getUnknownKinases(){
  const unknown=[];
  for (const k of allKinaseNames){
    const meta = lookupMetaForKinase(k);
    if (!meta.matched) unknown.push(k);
  }
  return unknown;
}

function updateUnknownInfo(){
  if (!(metaLoaded && klifsLoaded)){
    unknownInfo.textContent = "";
    return;
  }
  const unknown = getUnknownKinases();
  unknownInfo.innerHTML = `Unknown kinases：<span class="pill">${unknown.length}</span>`;
}

function buildUnknownMatchTable(){
  const unknown = getUnknownKinases();
  const metaNormList = metaRowsRaw.map(r=>{
    const parts = normalizeNameKeepParenAliases(r.NAME);
    return { NAME:r.NAME, FAMILY:r.FAMILY, GROUPS:r.GROUPS, p:parts.primary, a:parts.alias };
  });

  const rows=[];
  for (const k of unknown){
    const nk = normalizeNameBasic(k);
    let best = { score:-1, NAME:"", FAMILY:"", GROUPS:"", via:"" };

    // exact norm already failed (unknown), so do approx
    for (const m of metaNormList){
      const s1 = m.p ? similarityScore(nk, m.p) : 0;
      const s2 = m.a ? similarityScore(nk, m.a) : 0;
      const s = Math.max(s1,s2);
      if (s > best.score){
        best = { score:s, NAME:m.NAME, FAMILY:m.FAMILY, GROUPS:m.GROUPS, via:(s1>=s2?"approx(primary)":"approx(alias)") };
      }
    }

    rows.push({
      input_kinase: k,
      input_norm: nk,
      best_match_NAME: best.NAME,
      best_match_FAMILY: best.FAMILY,
      best_match_GROUPS: best.GROUPS,
      best_match_score: Number.isFinite(best.score) ? best.score : 0,
      match_via: best.via,
      reason_unknown: "No match in KLIFS_export.csv after normalization + alias lookup"
    });
  }
  rows.sort((a,b)=>b.best_match_score - a.best_match_score);
  return rows;
}

exportUnknownBtn.addEventListener("click", ()=>{
  try{
    if (!(metaLoaded && klifsLoaded)) return;
    const rows = buildUnknownMatchTable();
    if (!rows.length){ alert("目前沒有 unknown kinase。"); return; }

    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(rows), "unknown_matches");
    XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet([
      { key:"unknown_count", value: rows.length },
      { key:"meta_rows", value: metaRowsRaw.length },
      { key:"klifs_kinases", value: allKinaseNames.length },
    ]), "summary");

    XLSX.writeFile(wb, "unknown_kinases_match.xlsx");
  }catch(err){
    console.error(err);
    alert("匯出失敗：" + err.message);
  }
});

/* ===========================
   18) Init
   =========================== */
viewModeSelect.value = "kinase";
featureLabelModeSelect.value = "auto";
refreshUiLocks();

</script>
</body>
</html>
