<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Kinase IFP Heatmap Tool (KLIFS + Docking Compare)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      /* Nature/Cell-ish neutral paper UI */
      --bg:#f0eee9;
      --panel:#ffffff;
      --text:#111111;
      --muted:#919177;
      --primary:#297270;
      --primary-dark:#274753;
      --border:#d9d9d9;
      --border-strong:#bfbfbf;
      --danger:#e66d50;
      --ok:#1b5e20;
      --pill-bg:#eae4d1;
      --shadow:0 1px 3px rgba(0,0,0,0.06);

      /* Plot palette (journal-like) */
      --c-docking:#68945c;   
      --c-klifs:#6b5458;     
      --c-delta:#2c2f3b;     
      --c-thr-dock:#13393e;  /* red */
      --c-thr-klifs:#422517; /* teal */
      --c-mds-docking:#68945c;
      --c-mds-klifs:#6b5458;

    }

    
    body{
      font-family: Arial, Helvetica, system-ui, -apple-system, Segoe UI, sans-serif;
      margin:0;
      padding:16px 24px;
      background:var(--bg);
      color:var(--text);
    }

    h1{ margin:0 0 12px 0; color:var(--primary); text-align:center; }
    h2{ margin:0 0 10px 0; }
    h3{ margin:12px 0 6px 0; }

    .panel{
      background:var(--panel);
      border-radius:10px;
      padding:18px 20px;
      margin-bottom:16px;
      box-shadow:var(--shadow);
      border:1px solid #f0f0f0;
    }

    .muted{ color:var(--muted); font-size:13px; line-height:1.55; }
    .small{ font-size:12px; }
    .status{ font-weight:800; color:#8a5a00; }

    .pill{
      display:inline-block;
      padding:2px 10px;
      border-radius:999px;
      background:var(--pill-bg);
      color:#111;
      font-weight:800;
      font-size:12px;
      border:1px solid #e6e6e6;
    }

    label{
      font-weight:400;     /* ✅ 取消粗體 */
      display:block;
      margin-bottom:6px;
      color:#111;
    }


    input[type="file"], input[type="text"], input[type="number"], select, button{
      border:1px solid #cccccc;
      border-radius:8px;
      padding:10px;
      font-size:13px;
      background:#ffffff;
      width:100%;
      box-sizing:border-box;
    }

    button{
      background:var(--primary);
      color:#ffffff;
      border:none;
      font-weight:800;
      cursor:pointer;
      width:auto;
      padding:10px 14px;
    }
    button:hover{ background:var(--primary-dark); }
    button:disabled{ background:#cccccc; cursor:not-allowed; }
    input:disabled, select:disabled{ background:#f1f1f1; cursor:not-allowed; }

    hr{ border:0; border-top:1px solid #eeeeee; margin:14px 0; }

    .box-note{
      border:1px dashed #dddddd;
      border-radius:10px;
      padding:10px 12px;
      background:#fafafa;
    }

    .btn-secondary{
      background:var(--primary);
      color:#ffffff;
      border:1px solid #b3b59c;
    }
    .btn-secondary:hover{ background:var(--primary-dark); }
    
    button:disabled{
      background:#bfc1a9;
      color:#ffffff;              /* ← 這裡改 disabled 的字色 */
      cursor:not-allowed;
      border: none;
    }
    .btn-danger{
      background:#ab1d22;
      color:#ffffff;
      border:2px solid #a64036;
    }
    .btn-danger:hover{ background:#631216; }

    details{ border:1px solid #eeeeee; border-radius:10px; padding:10px 12px; background:#fafafa; }
    summary{ cursor:pointer; font-weight:800; color:#333344; outline:none; }
    .inline{ display:inline-flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .inline > * { width:auto; }

    /* New structured 3-column layout for section 1 */
    .grid3{
      display:grid;
      grid-template-columns: 1.05fr 1.25fr 1.05fr;
      gap:14px;
      align-items:stretch;
      margin-top:10px;
    }
    @media (max-width: 1200px){
      .grid3{ grid-template-columns: 1fr; }
    }

    .card{
      border:1px solid #ececec;
      border-radius:12px;
      padding:12px 12px;
      background:#ffffff;
    }
    .card h3{
      margin:0 0 10px 0;
      font-size:14px;
      color:#111;
    }
    .stack{ display:flex; flex-direction:column; gap:10px; }

    .selectrow{
      display:grid;
      grid-template-columns: 1fr 150px 1fr;
      gap:10px;
      align-items:stretch;
    }
    @media (max-width: 900px){
      .selectrow{ grid-template-columns: 1fr; }
    }

    .selectbox{ width:100%; min-height:240px; }
    .midcol{
      display:flex;
      flex-direction:column;
      gap:10px;
      justify-content:center;
      align-items:stretch;
    }
    .midcol button{ width:100%; }

    /* Plot containers */
    #klifsHeatmap, #dockHeatmap, #diffPlot, #mdsPlot, #confusionPlot{
      width:100%;
      min-height:520px;
      margin-top:10px;
      background:#ffffff;
      border:1px solid #eeeeee;
      border-radius:12px;
      overflow:hidden;
    }
    #dockHeatmap{
      border:2px solid var(--border-strong);
      box-shadow:none;
    }
    #klifsHeatmap{
      border:2px solid var(--border-strong);
    }
    /* Bar-chart legend strip like your KLIFS Y label line */
    .chart-strip{
      margin-top:6px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid #eeeeee;
      background:#fafafa;
    }

  /* ===== Data panel 3-column layout cards ===== */
.data-grid{
  display:grid;
  grid-template-columns: 1.05fr 1.2fr 1.05fr;
  gap:14px;
  margin-top:12px;
  align-items:stretch;
}

.data-card{
  border:1px solid var(--border);
  border-radius:12px;
  padding:14px 14px 12px 14px;
  background:#ffffff;
  box-shadow:0 1px 2px rgba(0,0,0,0.04);
  display:flex;
  flex-direction:column;
  min-height: 520px;
}

/* Part 1 / Part 2 換底色：更「分區」且不搶圖 */
/* Part 1 / Part 2 / Selection 分區底色 */
.data-card.part1,
.data-card.selection{
  background-color:#eae4d1; /* warm paper */
}
.data-card.part2{
  background:#d5e3d4;       /* cool paper */
}

/* ✅ FIX: Selection/Part1 內的 <select>/<input> 原本被全域 background:#fff 蓋掉
   → 用更高 specificity 覆寫，讓表單元件看起來「有跟著分區底色」 */
.data-card.part1 input[type="file"],
.data-card.part1 input[type="text"],
.data-card.part1 input[type="number"],
.data-card.part1 select,
.data-card.selection input[type="file"],
.data-card.selection input[type="text"],
.data-card.selection input[type="number"],
.data-card.selection select{
  background: rgba(255,255,255,0.55);
  border-color: rgba(0,0,0,0.18);
}

/* selectbox 讓列表更像嵌在卡片裡，不再純白一整塊 */
.data-card.selection select.selectbox{
  background: rgba(255,255,255,0.40);
}

/* Part2 保持更乾淨的白 */
.data-card.part2 input[type="file"],
.data-card.part2 input[type="text"],
.data-card.part2 input[type="number"],
.data-card.part2 select{
  background: rgba(255,255,255,0.92);
}


/* Card header */
.data-card .card-title{
  font-weight:900;
  margin:0 0 10px 0;
  color:#111;
  font-size:16px;          
  letter-spacing:0.2px;
  line-height:1.25;
}

.card-subtitle{
  font-weight:600;
  font-size:12px;
  color:var(--muted);
  margin-left:8px;
}


.data-card .field{ min-width: unset; }
.data-card .muted.small{ margin-top:6px; }

/* Buttons pinned to bottom center */
.card-actions{
  margin-top:auto;
  padding-top:12px;
  display:flex;
  justify-content:center;
  gap:10px;
  flex-wrap:wrap;
}
.card-actions button{
  min-width:140px;
}

/* Selection list layout inside the middle card */
.selection-grid{
  display:grid;
  grid-template-columns: 1fr 150px 1fr;
  gap:12px;
  align-items:stretch;
}
.selection-grid .selectbox{ min-height: 300px; }
.selection-mid{
  display:flex;
  flex-direction:column;
  justify-content:center;
  gap:10px;
}

/* ===== Move status pills to "1 Data" header right ===== */
.panel-head{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:12px;
}
.panel-head-right{
  text-align:right;
  margin-top:2px;
  min-width: 420px;
}
#loadInfoHeader{ margin-top:6px; }

/* ===== Hide Selection footer summary text (x axis / hover / PERMANOVA line) ===== */
.hide-selection-summary #selectionSummary{
  display:none !important;
}
    #exportHint{ display:none !important; }
    #thresholdHint{ display:none !important; }
  </style>
</head>

<body>
  <h1>Kinase Interaction Heatmap Tool</h1>

      <div class="panel" id="dataPanel">
    <div class="panel-head">
      <div>
        <h2>1 Data</h2>
        <div class="muted">
          Workflow: render KLIFS heatmap, then run Compare to generate Docking heatmap and statistics.
          Reset clears plots and UI state but keeps loaded files.
        </div>
      </div>
  
      <!-- ✅ Status pills moved to header right -->
      <div class="panel-head-right">
        <div class="status" id="statusText">Initialize: load Meta CSV</div>
        <div class="muted small" id="loadInfoHeader"></div>
      </div>
    </div>
  
    <div class="data-grid">
      <!-- Part 1 -->
      <div class="data-card part1">
        <div class="card-title">Part 1: KLIFS dataset</div>
  
        <div class="field">
          <label>Kinase family info (.csv)</label>
          <input type="file" id="metaCsvInput" accept=".csv,.tsv,text/csv,text/tab-separated-values" />
        </div>
  
        <div class="field" style="margin-top:10px;">
          <label>KLIFS IFP (.xlsx)</label>
          <input type="file" id="klifsIfpInput" accept=".xlsx" disabled />
        </div>
  
        <div class="field" style="margin-top:12px;">
          <label>View mode</label>
         <select id="viewModeSelect" disabled>
          <option value="group">Group</option>
          <option value="family">Family</option>
          <option value="kinase">Kinase</option>
          <option value="pdb">PDBs of selected kinase</option>
        </select>

          <div class="muted small">
            PDB mode requires selecting <span class="pill">at least one kinase</span>.
          </div>
        </div>
  
        <!-- ✅ Part 1 no longer shows status pills here -->
        <div style="margin-top:12px;" class="muted small" id="loadInfo"></div>
        <!-- 上面這個保留 id="loadInfo" 但會由 JS 寫入到 header 的 loadInfoHeader；這裡會在 JS 內清空 -->
      </div>
  
      <!-- Selection -->
      <div class="data-card selection">
       <div class="card-title">
      Selection
      <span class="card-subtitle">(Empty selection means all.)</span>
    </div>

  
        <div class="selection-grid">
          <div>
            <label id="availableLabel">Available kinases</label>
            <input type="text" id="availableSearch" placeholder="Search..." disabled style="margin:6px 0 8px 0;" />
            <select id="availableList" class="selectbox" multiple disabled></select>
            <div class="muted small">Double click to move.</div>
          </div>
  
          <div class="selection-mid">
            <button id="addBtn" disabled>Add</button>
            <button id="removeBtn" disabled>Remove</button>
            <button class="btn-secondary" id="clearSelectedBtn" disabled>Clear selection</button>
          </div>
  
          <div>
            <label id="selectedLabel">Selected kinase</label>
            <select id="selectedList" class="selectbox" multiple disabled></select>
            <div class="muted small">Double click to move.</div>
          </div>
        </div>
  
        <!-- ✅ Render KLIFS pinned to bottom center -->
        <div class="card-actions">
          <button id="runKlifsHeatmapBtn" disabled>Render KLIFS</button>
        </div>
      </div>
  
      <!-- Part 2 -->
      <div class="data-card part2">
        <div class="card-title">Part 2: Docking comparison</div>
  
        <div class="field">
          <label>KLIFS PDB Alignment (.csv/.tsv)</label>
          <input type="file" id="alignCsvInput" accept=".csv,.tsv,text/csv,text/tab-separated-values" disabled />
        </div>
  
        <div class="field" style="margin-top:10px;">
          <label>Docking pose (.xlsx)</label>
          <input type="file" id="dockXlsxInput" accept=".xlsx" disabled />
        </div>
  
        <div class="field" style="margin-top:10px;">
          <label>Docking PDB (for alignment)</label>
          <input type="text" id="dockPdbInput" placeholder="Example 6FYV" disabled />
          <div class="muted small">Case-insensitive. If empty, tool will try to infer from docking table column "pdb".</div>
        </div>
  
        <!-- ✅ Compare / Reset pinned to bottom center -->
        <div class="card-actions">
          <button id="compareBtn" disabled>Compare</button>
          <button class="btn-danger" id="resetBtn" disabled>Reset</button>
        </div>
      </div>
    </div>
  </div>

  <div class="panel">
    <h2>2 KLIFS heatmap</h2>

    <div class="muted small" id="klifsYLegend" style="margin-top:6px;">
      Y label (PDB mode): <span class="pill">KINASE/PDB/DFG/alphaC</span> (example: CLK4/6FYV/in/in).
    </div>
    <div class="muted small" id="summaryInfo" style="margin-top:8px;"></div>

    <div id="klifsHeatmap"></div>

    <hr/>

    <h3>Docking heatmap</h3>
    <div id="dockHeatmap"></div>

    <details style="margin-top:12px;" open>
      <summary>Docking comparison</summary>

      <div class="flex-row" style="margin-top:10px;">
      <div class="field" style="min-width:840px;">
        <label>KLIFS positive threshold</label>
    
        <div class="inline" style="gap:10px; align-items:center;">
          <input type="number" id="klifsThresholdInput" min="0" max="1" step="0.01" value="0.50" style="width:140px;" />
          <button class="btn-secondary" id="applyThresholdBtn" disabled>Apply</button>
    
          <span style="width:14px;"></span>
    
          <button class="btn-secondary" id="exportExcelBtn" disabled>Export Excel</button>
          <button class="btn-secondary" id="exportPlotsBtn" disabled>Export plots</button>
        </div>
    
        <div class="muted small" style="margin-top:6px;">
          Ground truth uses Docking frequency at least 50 percent. Test positive uses KLIFS frequency at least threshold.
        </div>
    
        <!-- 保留這兩個 id 給 JS，但你不想顯示：用 CSS 隱藏 -->
        <div class="muted small" id="thresholdHint" style="margin-top:6px;"></div>
        <div class="muted small" id="exportHint" style="margin-top:6px;"></div>
      </div>
    </div>

      <!-- “Histogram” strip (title/legend hint area) -->
      <div class="chart-strip muted small" id="diffStrip">
        Docking vs KLIFS: bars show frequency percent; line shows Docking − KLIFS delta.
        Thresholds: <span class="pill">Docking 50%</span> (solid red) and <span class="pill">KLIFS threshold</span> (dashed teal).
      </div>

      <div id="diffPlot"></div>
      <div style="height:10px;"></div>
      <div id="mdsPlot"></div>
      <div style="height:10px;"></div>
      <div id="confusionPlot"></div>
    </details>
  </div>

<script>
/* ===========================
   0 Global + DOM
   =========================== */
const statusText = document.getElementById("statusText");
const loadInfo   = document.getElementById("loadInfo");
const summaryInfo= document.getElementById("summaryInfo");
const exportHint = document.getElementById("exportHint");

const metaCsvInput   = document.getElementById("metaCsvInput");
const klifsIfpInput  = document.getElementById("klifsIfpInput");
const alignCsvInput  = document.getElementById("alignCsvInput");
const dockXlsxInput  = document.getElementById("dockXlsxInput");

const dockPdbInput   = document.getElementById("dockPdbInput");

const viewModeSelect = document.getElementById("viewModeSelect");
const runKlifsHeatmapBtn = document.getElementById("runKlifsHeatmapBtn");
const compareBtn = document.getElementById("compareBtn");
const resetBtn   = document.getElementById("resetBtn");

const exportExcelBtn = document.getElementById("exportExcelBtn");
const exportPlotsBtn = document.getElementById("exportPlotsBtn");
const klifsThresholdInput = document.getElementById("klifsThresholdInput");
const applyThresholdBtn = document.getElementById("applyThresholdBtn");
const thresholdHint = document.getElementById("thresholdHint");

const availableList = document.getElementById("availableList");
const selectedList  = document.getElementById("selectedList");
  const availableSearch = document.getElementById("availableSearch");
const addBtn = document.getElementById("addBtn");
const removeBtn = document.getElementById("removeBtn");
const clearSelectedBtn = document.getElementById("clearSelectedBtn");
const availableLabel = document.getElementById("availableLabel");
const selectedLabel  = document.getElementById("selectedLabel");

const kinaseKeyName = "kinase";

// load flags
let metaLoaded=false, klifsLoaded=false, alignLoaded=false, dockLoaded=false;

// meta
let metaRowsRaw=[];
let metaNormToRow = new Map();
let familyList=[], groupList=[];

// KLIFS IFP
let klifsRaw2D=null;
let klifsFeatureKeys=[];        // "1-HP","1-HB"... "85-HB"
let klifsKinaseFreqRows=[];     // per-kinase freq %
let klifsStructBinaryRows=[];   // per-structure 0/1 + meta
let allKinaseNames=[];

// alignment
let alignmentMapById = new Map();          // structure_ID -> {pos->residueNumber}
let alignmentPdbById = new Map();          // structure_ID -> pdb optional
let alignmentPdbToStructIds = new Map();   // pdbNorm -> [structure_ID,...]

// docking
let dockRaw2D=null;
let dockBinaryRows=[];
let dockFreqRow=null;
let lastDockAlignmentSid="";

// workflow / compare state
let viewMode="kinase";
let lastKlifsRows=[];
let residueModeActive=false;
let residueFeatureMap = new Map();     // feature -> "123-HP" or "_HP"
let lastKlifsHighlightedRowLabel = "";

// derived compare state
let lastCompare = {
  dockingPdb: "",
  alignmentSid: "",
  compareMode: "",
  compareSelectedLabel: "",
  klifsStructCount: 0,
  dockingLigCount: 0,
  permanovaF: null,
  permanovaP: null,
  confusion: null,
};

/* ===========================
   Helpers
   =========================== */
function plotlyPaperLayoutBase(){
  return {
    paper_bgcolor: "#FFFFFF",
    plot_bgcolor: "#FFFFFF",
    font: {
      family: "Arial, Helvetica, sans-serif",
      size: 12,
      color: "#111111"
    },
    title: { font: { size: 13, color:"#111111" } }
  };
}

function setStatus(msg){ statusText.textContent = msg; }
function safeTrim(v){ return (v==null) ? "" : String(v).trim(); }
function clamp01(x){ x=Number(x); if(!Number.isFinite(x)) return 0.5; return Math.min(1, Math.max(0, x)); }

function nowTag(){
  const d = new Date();
  const pad = (n)=>String(n).padStart(2,"0");
  return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
}
function sanitizeFileToken(s){
  return safeTrim(s).replace(/[^A-Za-z0-9._-]+/g, "_").replace(/_+/g,"_").replace(/^_+|_+$/g,"");
}
function makeBaseExportName(){
  const dp = sanitizeFileToken(lastCompare.dockingPdb || safeTrim(dockPdbInput.value) || "DockingPDB");
  const sel = sanitizeFileToken(lastCompare.compareSelectedLabel || "Selection");
  return `${dp}__vs__${sel}__${nowTag()}`;
}
function downloadDataUrl(dataUrl, filename){
  const a = document.createElement("a");
  a.href = dataUrl;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
}

function readXlsxArrayBuffer(buffer){
  const data = new Uint8Array(buffer);
  const wb = XLSX.read(data, { type:"array" });
  const ws = wb.Sheets[wb.SheetNames[0]];
  return XLSX.utils.sheet_to_json(ws, { header:1, raw:true, defval:null });
}

function parseCsvLoose(text){
  const lines = text.split(/\r?\n/).filter(l => l.trim() !== "");
  if (lines.length < 2) return { header:[], rows:[] };

  const split = (line) => {
    const c = line.split(",");
    const t = line.split("\t");
    const parts = (t.length > c.length) ? t : c;
    return parts.map(x => x.trim());
  };

  const header = split(lines[0]);
  const rows = [];
  for (let i=1; i<lines.length; i++) rows.push(split(lines[i]));
  return { header, rows };
}

function findCol(header, candidates){
  const lower = header.map(h => safeTrim(h).toLowerCase());
  for (const cand of candidates){
    const idx = lower.indexOf(String(cand).toLowerCase());
    if (idx >= 0) return idx;
  }
  return -1;
}

function shortenLabel(s, maxLen, mode){
  const str = String(s ?? "");
  const n = Math.max(0, Number(maxLen)||0);
  if (!n) return str;
  if (str.length <= n) return str;

  const ell="…";
  if (n<=1) return ell;

  if (mode==="head"){
    return str.slice(0, n-1) + ell;
  }
  if (mode==="tail"){
    return ell + str.slice(str.length-(n-1));
  }
  const keep=n-1;
  const left=Math.ceil(keep/2);
  const right=Math.floor(keep/2);
  return str.slice(0,left) + ell + str.slice(str.length-right);
}

function normalizePdb(pdb){ return safeTrim(pdb).toLowerCase(); }

/* Normalize DFG/alphaC to in/out/na (simple) */
function normalizeStateInOut(s){
  const v = safeTrim(s).toLowerCase();
  if (!v) return "na";
  if (v.includes("in")) return "in";
  if (v.includes("out")) return "out";
  if (v === "i") return "in";
  if (v === "o") return "out";
  return v.replace(/\s+/g,"_");
}

/* ===========================
   Name normalization
   =========================== */
function normalizeNameBasic(s){
  const up = safeTrim(s).toUpperCase();
  const noParen = up.replace(/\(.*?\)/g, " ");
  return noParen.replace(/[^A-Z0-9]+/g, "");
}
function normalizeNameKeepParenAliases(s){
  const raw = safeTrim(s);
  const m = raw.match(/^(.*?)\((.*?)\)\s*$/);
  if (!m) return { primary: normalizeNameBasic(raw), alias:"" };
  return { primary: normalizeNameBasic(m[1]), alias: normalizeNameBasic(m[2]) };
}
function lookupMetaForKinase(kinaseName){
  const nk = normalizeNameBasic(kinaseName);
  let row = metaNormToRow.get(nk);
  if (row) return { matched:true, FAMILY: row.FAMILY||"", GROUPS: row.GROUPS||"" };

  const parts = normalizeNameKeepParenAliases(kinaseName);
  row = metaNormToRow.get(parts.primary) || metaNormToRow.get(parts.alias);
  if (row) return { matched:true, FAMILY: row.FAMILY||"", GROUPS: row.GROUPS||"" };

  return { matched:false, FAMILY:"", GROUPS:"" };
}

/* ===========================
   UI locks
   =========================== */
function refreshUiLocks(){
  const coreReady = metaLoaded && klifsLoaded;

  klifsIfpInput.disabled   = !metaLoaded;
  alignCsvInput.disabled   = !(metaLoaded && klifsLoaded);
  dockXlsxInput.disabled   = !(metaLoaded && klifsLoaded && alignLoaded);

  viewModeSelect.disabled  = !coreReady;
  runKlifsHeatmapBtn.disabled = !coreReady;

  const listReady = coreReady;
  availableList.disabled = !listReady;
  selectedList.disabled  = !listReady;
  addBtn.disabled        = !listReady;
  removeBtn.disabled     = !listReady;
  clearSelectedBtn.disabled = !listReady;
if (availableSearch) availableSearch.disabled = !listReady;

  dockPdbInput.disabled = !(metaLoaded && klifsLoaded && alignLoaded && dockLoaded);

  const compareReady = coreReady && alignLoaded && dockLoaded;
  compareBtn.disabled = !compareReady;

  resetBtn.disabled = !coreReady;

  const canExport = residueModeActive && !!dockFreqRow;
  exportExcelBtn.disabled = !canExport;
  exportPlotsBtn.disabled = !canExport;

  const canApplyThr = residueModeActive && !!dockFreqRow;
  applyThresholdBtn.disabled = !canApplyThr;

  thresholdHint.textContent = canApplyThr
    ? "Edit the threshold, then click Apply to recompute metrics."
    : "Run Compare to enable threshold apply.";

  /* ===== Status pills (ONLY source) ===== */
  const statusHtml =
    `Meta <span class="pill">${metaLoaded ? "OK" : "Missing"}</span> ` +
    `KLIFS IFP <span class="pill">${klifsLoaded ? "OK" : "Missing"}</span> ` +
    `Alignment <span class="pill">${alignLoaded ? "OK" : "Missing"}</span> ` +
    `Docking <span class="pill">${dockLoaded ? "OK" : "Missing"}</span>`;

  // 舊位置不再顯示
  if (loadInfo) loadInfo.innerHTML = "";

  // Header 右側顯示
  const loadInfoHeader = document.getElementById("loadInfoHeader");
  if (loadInfoHeader) loadInfoHeader.innerHTML = statusHtml;

  if (exportHint) exportHint.textContent = canExport ? "" : "";
}


/* ===========================
   Meta CSV
   =========================== */
function parseMetaCsv(text){
  const { header, rows } = parseCsvLoose(text);
  const idxName   = findCol(header, ["name","NAME"]);
  const idxFamily = findCol(header, ["family","FAMILY"]);
  const idxGroup  = findCol(header, ["groups","group","GROUPS","GROUP"]);
  if (idxName<0 || idxFamily<0 || idxGroup<0){
    throw new Error("Meta CSV must include NAME, FAMILY, GROUPS columns.");
  }

  metaRowsRaw = [];
  metaNormToRow = new Map();
  const famSet = new Set();
  const grpSet = new Set();

  for (const r of rows){
    if (!r || r.length <= Math.max(idxName, idxFamily, idxGroup)) continue;
    const NAME = safeTrim(r[idxName]);
    if (!NAME) continue;
    const FAMILY = safeTrim(r[idxFamily]);
    const GROUPS = safeTrim(r[idxGroup]);
    const rowObj = { NAME, FAMILY, GROUPS };
    metaRowsRaw.push(rowObj);

    const parts = normalizeNameKeepParenAliases(NAME);
    if (parts.primary) metaNormToRow.set(parts.primary, rowObj);
    if (parts.alias) metaNormToRow.set(parts.alias, rowObj);

    if (FAMILY) famSet.add(FAMILY);
    if (GROUPS) grpSet.add(GROUPS);
  }

  familyList = Array.from(famSet).sort((a,b)=>String(a).localeCompare(String(b)));
  groupList  = Array.from(grpSet).sort((a,b)=>String(a).localeCompare(String(b)));
}

metaCsvInput.addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;
  try{
    setStatus("Loading meta CSV...");
    parseMetaCsv(await file.text());
    metaLoaded = true;
    setStatus("Meta CSV loaded. Load KLIFS IFP XLSX.");
  }catch(err){
    console.error(err);
    metaLoaded=false;
    setStatus("Meta CSV load failed: " + err.message);
  }finally{
    refreshUiLocks();
    rebuildAvailableSelectedLists(true);
  }
});

/* ===========================
   KLIFS IFP load -> HP/HB collapse
   =========================== */
const positionRowIndex = 1;
const ifpTypeRowIndex  = 2;
const metaRowsCount    = 5;

function detectIfpColumnsFromHeader(data2D){
  const header = data2D?.[0] || [];
  const idx=[];
  for (let c=0;c<header.length;c++){
    const name = safeTrim(header[c]);
    if (/^IFP_/i.test(name)) idx.push(c);
  }
  idx.sort((a,b)=>a-b);
  return idx;
}

function collapseKlifsToHpHb(data2D, nMetaCols, ifpCols){
  const headerRow = data2D[0] || [];
  const positionRow = data2D[positionRowIndex] || [];
  const ifpTypeRow = data2D[ifpTypeRowIndex] || [];

  const hpTypes = new Set([1,2,3]);
  const hbTypes = new Set([4,5,6,7]);

  const posToHpCols = {};
  const posToHbCols = {};

  for (const colIdx of ifpCols){
    const pos = positionRow[colIdx];
    const t = ifpTypeRow[colIdx];
    if (pos==null || t==null || pos==="" || t==="") continue;
    const posInt = parseInt(pos,10);
    const tInt = parseInt(t,10);
    if (!Number.isFinite(posInt) || !Number.isFinite(tInt)) continue;
    if (!posToHpCols[posInt]) posToHpCols[posInt]=[];
    if (!posToHbCols[posInt]) posToHbCols[posInt]=[];
    if (hpTypes.has(tInt)) posToHpCols[posInt].push(colIdx);
    else if (hbTypes.has(tInt)) posToHbCols[posInt].push(colIdx);
  }

  const allPos0 = Array.from(new Set([
    ...Object.keys(posToHpCols).map(Number),
    ...Object.keys(posToHbCols).map(Number),
  ])).sort((a,b)=>a-b);

  const metaKeys=[];
  for (let c=0;c<nMetaCols;c++){
    const name = safeTrim(headerRow[c]);
    if (!name) continue;
    metaKeys.push({idx:c, name});
  }

  const structRows=[];
  for (let r=metaRowsCount; r<data2D.length; r++){
    const row = data2D[r];
    if (!row || row.every(v=>v==null || String(v).trim()==="")) continue;

    const obj={};
    for (const mk of metaKeys) obj[mk.name] = row[mk.idx];

    for (const pos0 of allPos0){
      const hpCols = posToHpCols[pos0] || [];
      const hbCols = posToHbCols[pos0] || [];
      let hp=0, hb=0;
      for (const idx of hpCols){ const v=Number(row[idx]); if (Number.isFinite(v) && v>0){ hp=1; break; } }
      for (const idx of hbCols){ const v=Number(row[idx]); if (Number.isFinite(v) && v>0){ hb=1; break; } }
      const p = pos0 + 1;
      obj[`${p}-HP`] = hp;
      obj[`${p}-HB`] = hb;
    }
    structRows.push(obj);
  }

  const featureKeys=[];
  for (const pos0 of allPos0){
    const p=pos0+1;
    featureKeys.push(`${p}-HP`, `${p}-HB`);
  }
  return { structRows, featureKeys };
}

function pickMetaField(obj, candidates){
  for (const c of candidates){
    if (Object.prototype.hasOwnProperty.call(obj, c) && safeTrim(obj[c])!=="") return safeTrim(obj[c]);
  }
  const keys = Object.keys(obj||{});
  const lowMap = new Map(keys.map(k=>[k.toLowerCase(), k]));
  for (const c of candidates){
    const k = lowMap.get(String(c).toLowerCase());
    if (k && safeTrim(obj[k])!=="") return safeTrim(obj[k]);
  }
  return "";
}

function computeKinaseFreqAndStructBinary(structRows, featureKeys, kinaseColName, structureColName){
  const groups = new Map();
  const structBinary = [];

  for (const r of structRows){
    const k = r[kinaseColName];
    if (!k) continue;
    if (!groups.has(k)) groups.set(k, []);
    groups.get(k).push(r);

    const bin = {};
    bin[kinaseKeyName] = k;
    bin.structure_ID = r[structureColName];

    const pdb = pickMetaField(r, ["pdb","PDB","pdb_code","pdbcode","pdb id","pdb_id"]);
    const dfg = pickMetaField(r, ["DFG","dfg","DFG_state","dfg_state","DFG conformation","dfg conformation"]);
    const aC  = pickMetaField(r, ["alphaC","alpha-c","alpha_c","alphaC_state","alpha-c helix","alphaC helix","alphaC_helix","alpha_c_helix"]);

    bin.__pdb = pdb || "";
    bin.__dfg = dfg || "";
    bin.__alphac = aC || "";

    for (const f of featureKeys) bin[f] = Number(r[f]) ? 1 : 0;
    structBinary.push(bin);
  }

  const kinases = Array.from(groups.keys()).sort((a,b)=>String(a).localeCompare(String(b)));
  const freqRows = [];

  for (const k of kinases){
    const rows = groups.get(k);
    const out = {};
    out[kinaseKeyName]=k;
    out.__n = rows.length;
    out.__label = `${k} (n=${rows.length})`;
    for (const f of featureKeys){
      let sum=0;
      for (const r of rows) sum += Number(r[f]) ? 1 : 0;
      out[f] = rows.length ? (sum/rows.length)*100 : 0;
    }
    freqRows.push(out);
  }

  return { kinases, freqRows, structBinary };
}

klifsIfpInput.addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;
  try{
    setStatus("Loading KLIFS IFP XLSX...");
    const buffer = await file.arrayBuffer();
    klifsRaw2D = readXlsxArrayBuffer(buffer);

    const header = (klifsRaw2D[0] || []).map(safeTrim);
    const ifpCols = detectIfpColumnsFromHeader(klifsRaw2D);
    if (!ifpCols.length) throw new Error("No IFP_ columns found.");

    const kinaseIdx = findCol(header, ["kinase"]);
    const structureIdx = findCol(header, ["structure_id","structure id","structureid","structure_ID","structureId"]);
    if (kinaseIdx<0) throw new Error("KLIFS IFP must include column kinase.");
    if (structureIdx<0) throw new Error("KLIFS IFP must include column structure_ID.");

    const firstIfpCol = Math.min(...ifpCols);
    const nMetaCols = Math.max(firstIfpCol, 4);

    const build = collapseKlifsToHpHb(klifsRaw2D, nMetaCols, ifpCols);
    klifsFeatureKeys = build.featureKeys.slice();

    const structRows = build.structRows.map(r=>{
      const out = { ...r };
      out[kinaseKeyName] = r[header[kinaseIdx]];
      out.structure_ID = r[header[structureIdx]];
      return out;
    });

    const calc = computeKinaseFreqAndStructBinary(structRows, klifsFeatureKeys, kinaseKeyName, "structure_ID");
    allKinaseNames = calc.kinases.slice();
    klifsKinaseFreqRows = calc.freqRows.slice();
    klifsStructBinaryRows = calc.structBinary.slice();

    klifsLoaded = true;
    setStatus("KLIFS IFP loaded. Load alignment CSV/TSV to enable Compare.");
  }catch(err){
    console.error(err);
    klifsLoaded=false;
    setStatus("KLIFS IFP load failed: " + err.message);
  }finally{
    refreshUiLocks();
    rebuildAvailableSelectedLists(true);
  }
});

/* ===========================
   Alignment CSV/TSV load
   =========================== */
function parseAlignmentCsv(text){
  const { header, rows } = parseCsvLoose(text);
  if (!header?.length) throw new Error("Alignment CSV/TSV is empty.");

  const idxPdb    = findCol(header, ["pdb"]);
  const idxStruct = findCol(header, ["structure_id","structure id","structureid","structure_ID","structureId"]);
  if (idxStruct < 0) throw new Error("Alignment must include structure_ID.");

  const posColIdx = new Map();
  for (let c=0;c<header.length;c++){
    const p = parseInt(header[c], 10);
    if (Number.isFinite(p) && p >= 1 && p <= 85) posColIdx.set(p, c);
  }
  if (posColIdx.size < 10) throw new Error("Alignment header must include 1..85 columns.");

  alignmentMapById = new Map();
  alignmentPdbById = new Map();
  alignmentPdbToStructIds = new Map();

  let n=0;
  for (const row of rows){
    if (!row || row.every(v => v == null || String(v).trim()==="")) continue;
    const structId = safeTrim(row[idxStruct]);
    if (!structId) continue;

    const map = {};
    for (let p=1; p<=85; p++){
      const c = posColIdx.get(p);
      const valStr = (c==null) ? "" : safeTrim(row[c]);
      if (!valStr || valStr === "_" || valStr === "-"){ map[p]=null; continue; }
      const num = parseInt(valStr, 10);
      map[p] = Number.isFinite(num) ? num : null;
    }
    alignmentMapById.set(structId, map);
    n++;

    const pdb = (idxPdb>=0) ? safeTrim(row[idxPdb]) : "";
    if (pdb){
      alignmentPdbById.set(structId, pdb);
      const key = normalizePdb(pdb);
      if (!alignmentPdbToStructIds.has(key)) alignmentPdbToStructIds.set(key, []);
      alignmentPdbToStructIds.get(key).push(structId);
    }
  }

  for (const [k, ids] of alignmentPdbToStructIds.entries()){
    ids.sort((a,b)=>String(a).localeCompare(String(b)));
  }

  return n;
}

alignCsvInput.addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;
  try{
    setStatus("Loading alignment CSV/TSV...");
    const text = await file.text();
    const n = parseAlignmentCsv(text);
    alignLoaded = true;
    setStatus(`Alignment loaded (rows=${n}). Load docking pose to enable Compare.`);
  }catch(err){
    console.error(err);
    alignLoaded=false;
    setStatus("Alignment load failed: " + err.message);
  }finally{
    refreshUiLocks();
  }
});

/* ===========================
   Docking load
   =========================== */
dockXlsxInput.addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;
  try{
    setStatus("Loading docking pose XLSX...");
    const buffer = await file.arrayBuffer();
    dockRaw2D = readXlsxArrayBuffer(buffer);
    dockLoaded = true;
    setStatus("Docking pose loaded (Optional) Enter PDB code");
  }catch(err){
    console.error(err);
    dockLoaded=false;
    setStatus("Docking pose load failed: " + err.message);
  }finally{
    refreshUiLocks();
  }
});
dockPdbInput.addEventListener("input", refreshUiLocks);

/* ===========================
   Selection list UI
   =========================== */
function getSelectedValues(){
  return Array.from(selectedList.options).map(o=>o.value);
}

function moveSelected(fromSel, toSel){
  const opts = Array.from(fromSel.selectedOptions);
  for (const opt of opts){
    const exists = Array.from(toSel.options).some(o=>o.value===opt.value);
    if (!exists){
      const n=document.createElement("option");
      n.value=opt.value; n.textContent=opt.textContent;
      toSel.appendChild(n);
    }
    fromSel.removeChild(opt);
  }
  rebuildAvailableSelectedLists(false);
}

addBtn.addEventListener("click", ()=>moveSelected(availableList, selectedList));
removeBtn.addEventListener("click", ()=>moveSelected(selectedList, availableList));
availableList.addEventListener("dblclick", ()=>moveSelected(availableList, selectedList));
selectedList.addEventListener("dblclick", ()=>moveSelected(selectedList, availableList));

clearSelectedBtn.addEventListener("click", ()=>{
  selectedList.innerHTML = "";
  rebuildAvailableSelectedLists(false);
});

function rebuildAvailableSelectedLists(resetSelected=false){
  if (!(metaLoaded && klifsLoaded)){
    availableList.innerHTML="";
    selectedList.innerHTML="";
    return;
  }

  viewMode = viewModeSelect.value || "kinase";
  let items=[];
  if (viewMode==="kinase") items = allKinaseNames.slice();
  else if (viewMode==="family") items = familyList.slice();
  else if (viewMode==="group") items = groupList.slice();
  else if (viewMode==="pdb") items = allKinaseNames.slice();

  items.sort((a,b)=>String(a).localeCompare(String(b)));

if (resetSelected){
  selectedList.innerHTML="";
}

const q = safeTrim(availableSearch?.value || "").toLowerCase();
const selectedSet = new Set(getSelectedValues());

availableList.innerHTML="";
for (const it of items){
  if (selectedSet.has(it)) continue;

  // ✅ search filter (case-insensitive)
  if (q && !String(it).toLowerCase().includes(q)) continue;

  const o=document.createElement("option");
  o.value=it;
  o.textContent=it;
  availableList.appendChild(o);
}

  if (viewMode==="kinase"){
    availableLabel.textContent = "Available kinases";
    selectedLabel.textContent  = "Selected kinases";
  }else if (viewMode==="family"){
    availableLabel.textContent = "Available families";
    selectedLabel.textContent  = "Selected families";
  }else if (viewMode==="group"){
    availableLabel.textContent = "Available groups";
    selectedLabel.textContent  = "Selected groups";
  }else{
    availableLabel.textContent = "Available kinases";
    selectedLabel.textContent  = "Selected kinase";
  }
}
viewModeSelect.addEventListener("change", ()=>{ rebuildAvailableSelectedLists(true); });
availableSearch?.addEventListener("input", ()=>rebuildAvailableSelectedLists(false));

/* ===========================
   Selection scope for statistics
   =========================== */
function getCurrentSelectionScope(){
  const mode = viewModeSelect.value || "kinase";
  const picked = getSelectedValues();

  let items = [];
  if (picked.length){
    items = picked.slice();
  }else{
    if (mode==="kinase") items = allKinaseNames.slice();
    else if (mode==="family") items = familyList.slice();
    else if (mode==="group") items = groupList.slice();
    else items = allKinaseNames.slice();
  }

  const label = `${mode}_${items.join("+")}`;
  return { mode, items, label };
}

function filterKlifsStructBinaryByScope(scope){
  const mode = scope.mode;
  const set = new Set(scope.items);

  if (mode==="kinase"){
    return klifsStructBinaryRows.filter(r=>set.has(safeTrim(r[kinaseKeyName])));
  }
  if (mode==="family"){
    return klifsStructBinaryRows.filter(r=>{
      const meta = lookupMetaForKinase(r[kinaseKeyName]);
      return set.has(meta.FAMILY);
    });
  }
  if (mode==="group"){
    return klifsStructBinaryRows.filter(r=>{
      const meta = lookupMetaForKinase(r[kinaseKeyName]);
      return set.has(meta.GROUPS);
    });
  }
  return klifsStructBinaryRows.filter(r=>set.has(safeTrim(r[kinaseKeyName])));
}

function freqFromBinaryRows(binaryRows, label){
  const out = { __n: binaryRows.length, __label: `${label} (n=${binaryRows.length})` };
  for (const f of klifsFeatureKeys){
    let sum=0;
    for (const r of binaryRows) sum += Number(r[f]) ? 1 : 0;
    out[f] = binaryRows.length ? (sum/binaryRows.length)*100 : 0;
  }
  return out;
}

/* ===========================
   Residue mapping (from alignment structure_ID)
   =========================== */
function buildResidueMapsByStructureId(structureId){
  const rowMap = alignmentMapById.get(structureId);
  const resToKlifs = new Map();
  const klifsToRes = new Map();
  if (!rowMap) return { resToKlifs, klifsToRes };

  for (let p=1; p<=85; p++){
    const res = rowMap[p];
    if (res==null) continue;
    klifsToRes.set(p, res);
    if (!resToKlifs.has(res)) resToKlifs.set(res, p);
  }
  return { resToKlifs, klifsToRes };
}

// missing residue -> _HP / _HB
function buildResidueFeatureMapFromSid(sid){
  const fmap = new Map();
  const { klifsToRes } = buildResidueMapsByStructureId(sid);

  for (const f of klifsFeatureKeys){
    const m = String(f).match(/^(\d+)\-(HP|HB)$/i);
    if (!m){ fmap.set(f, f); continue; }
    const pos=parseInt(m[1],10);
    const kind=m[2].toUpperCase();
    const res=klifsToRes.get(pos);
    if (res==null) fmap.set(f, `_${kind}`);
    else fmap.set(f, `${res}-${kind}`);
  }
  return fmap;
}

/* ===========================
   Alignment picking by PDB
   =========================== */
function autoPickAlignmentStructureIdForPdb(pdb){
  const key = normalizePdb(pdb);
  if (!key) return "";
  const ids = alignmentPdbToStructIds.get(key) || [];
  if (!ids.length) return "";
  for (const sid of ids){
    if (alignmentMapById.has(sid)) return sid;
  }
  return ids[0] || "";
}

/* ===========================
   Plotly styles
   =========================== */
function makeTwoToneColorscale(){
  const t = 0.5;
  return [
    [0.00, "#f7f7f7"],
    [0.20, "#e5e7eb"],
    [0.40, "#ddbb99"],
    [t - 1e-6, "#db9c5e"],
    [t, "#ed6d3d"],
    [0.75, "#cc5d20"],
    [1.00, "#9f5221"]
  ];
}

/* ===========================
   FIXED 3-COLUMN HEATMAP LAYOUT (CRITICAL)
   Always reserve: [dendro gutter] [label gutter] [heatmap]
   =========================== */
const HEATMAP_GUTTER = {
  dendroEnd: 0.040,
  labelEnd:  0.150,
  gap: 0.010,
  dendroLineWidth: 1.5,
  dendroColor: "#111111",
  yLabelFontSize: 13,
  xTickFontSize: 11
};

function buildKlifsPositionTick(featureMapForAxis){
  const xVals = klifsFeatureKeys.map((_, i) => i);

  const ticktext = klifsFeatureKeys.map(f=>{
    const m = String(f).match(/^(\d+)\-(HP|HB)$/i);
    if (!m) return "";
    const kind = m[2].toUpperCase();

    // only label HP columns to avoid overcrowding
    if (kind !== "HP") return "";

    if (!featureMapForAxis){
      return `${m[1]}-HP`;
    }

    const mapped = featureMapForAxis.get(f);

    // if aligned residue exists
    if (mapped && mapped !== "_HP"){
      return mapped; // e.g. "123-HP"
    }

    if (mapped === "_HP"){
      return "_-HP";
    }

    return `${m[1]}-HP`;
  });

  return { xVals, tickvals: xVals, ticktext };
}

function buildColumnLabelForHover(fmap){
  // single label per column (index) for hover
  return klifsFeatureKeys.map(f=>{
    const m = String(f).match(/^(\d+)\-(HP|HB)$/i);
    const pos = m ? m[1] : "?";
    const kind = m ? m[2].toUpperCase() : "";
    if (!fmap) return `KLIFS ${pos}-${kind}`;
    const mapped = fmap.get(f) || "";
    if (mapped && mapped !== f) return `KLIFS ${pos}-${kind} • ${mapped}`;
    return `KLIFS ${pos}-${kind}`;
  });
}

/* ---------- FIX: heatmap hover garbage removal ----------
   Plotly does not reliably support %{customdata.someField} when customdata is object.
   We provide 2D customdata: customdata[i][j] = [rowLabel, columnLabel]
--------------------------------------------------------- */
function buildHeatmapCustomdata(rowFull, colLabels){
  const out = [];
  for (let i=0;i<rowFull.length;i++){
    const row = [];
    for (let j=0;j<colLabels.length;j++){
      row.push([rowFull[i], colLabels[j]]);
    }
    out.push(row);
  }
  return out;
}

function drawHeatmapFixedGutter({
  divId,
  rows,
  titleText,
  featureMapForHover,
  dendroSegments,
  highlightFullLabel,
}){
  if (!rows || !rows.length){
    Plotly.purge(divId);
    return;
  }

  const base = plotlyPaperLayoutBase();
  const { dendroEnd, labelEnd, gap } = HEATMAP_GUTTER;
  const heatStart = labelEnd + gap;

  const rowFull = rows.map(r => r.__label ?? r[kinaseKeyName] ?? "row");
  const rowDisp = rowFull.map(s => shortenLabel(s, 40, "tail"));

  const rowDispColored = rowDisp.map((s, i)=>{
    if (highlightFullLabel && rowFull[i] === highlightFullLabel){
      return `<b><span style="color:#b00020">${s}</span></b>`;
    }
    return s;
  });
  const yIdx = rowDispColored.map((_, i) => i);

  const { xVals, tickvals, ticktext } = buildKlifsPositionTick(featureMapForHover);
  const colLabels = buildColumnLabelForHover(featureMapForHover);

  const z = rows.map(r=>klifsFeatureKeys.map(f=>{
    const v=Number(r[f]);
    return Number.isFinite(v) ? v : 0;
  }));

  const customdata = buildHeatmapCustomdata(rowFull, colLabels);

  const heatmapTrace = {
    x: xVals,
    y: yIdx,
    z,
    type:"heatmap",
    colorscale: makeTwoToneColorscale(),
    zmin:0, zmax:100,
    colorbar:{ title:"Frequency percent" },
    customdata,
    hovertemplate:
      "<b>%{customdata[0]}</b><br>" +
      "%{customdata[1]}<br>" +
      "Value: %{z:.1f}<extra></extra>",
    xaxis: "x2",
    yaxis: "y"
  };

  const dendroTrace = {
    x: [],
    y: [],
    type: "scatter",
    mode: "lines",
    line: { color: HEATMAP_GUTTER.dendroColor, width: HEATMAP_GUTTER.dendroLineWidth },
    hoverinfo: "skip",
    xaxis: "x",
    yaxis: "y"
  };

  if (dendroSegments && Array.isArray(dendroSegments.x) && dendroSegments.x.length){
    dendroTrace.x = dendroSegments.x;
    dendroTrace.y = dendroSegments.y;
  }

  const annotations = rowDispColored.map((lab, i)=>({
    xref: "paper",
    yref: "y",
    x: labelEnd - 0.012,
    y: i,
    xanchor: "right",
    align: "right",
    text: lab,
    showarrow: false,
    font: { size: HEATMAP_GUTTER.yLabelFontSize, color: "#111111" }
  }));

  const layout = {
    ...base,
    title: { text: titleText },
    margin: { l: 24, r: 24, t: 46, b: 128 },

    xaxis: {
      domain: [0, dendroEnd],
      showticklabels: false,
      ticks: "",
      showgrid: false,
      zeroline: false,
      autorange: "reversed",
      range: dendroSegments && dendroSegments.maxH ? [0, dendroSegments.maxH*1.02] : undefined
    },

    xaxis2: {
      domain: [heatStart, 1],
      tickmode: "array",
      tickvals,
      ticktext,
      tickangle: -90,
      tickfont: { size: HEATMAP_GUTTER.xTickFontSize, color:"#111111" },
      title: "Aligned residue number",
      showgrid: false,
      zeroline: false
    },

    yaxis: {
      domain: [0, 1],
      showticklabels: false,
      ticks: "",
      showgrid: false,
      zeroline: false,
      range: [-0.5, rows.length - 0.5]
    },

    annotations
  };

  Plotly.newPlot(divId, [dendroTrace, heatmapTrace], layout, { responsive:true });
}

/* ===========================
   PDB clustering + dendrogram (fixed)
   =========================== */
function rowVector01(row){
  return klifsFeatureKeys.map(f=>{
    const v = Number(row[f]);
    return (Number.isFinite(v) && v>0) ? 1 : 0;
  });
}
function jaccardDistanceVec(a,b){
  let inter=0, uni=0;
  for (let i=0;i<a.length;i++){
    const ai=a[i]?1:0, bi=b[i]?1:0;
    if (ai||bi) uni++;
    if (ai&&bi) inter++;
  }
  if (!uni) return 0;
  return 1 - inter/uni;
}
function pairwiseDistanceMatrixFromVectors(vecs){
  const n = vecs.length;
  const D = Array.from({length:n},()=>Array(n).fill(0));
  for (let i=0;i<n;i++){
    for (let j=i+1;j<n;j++){
      const d = jaccardDistanceVec(vecs[i], vecs[j]);
      D[i][j]=d; D[j][i]=d;
    }
  }
  return D;
}
function hclustAverage(distMat){
  const n = distMat.length;
  let clusters = [];
  for (let i=0;i<n;i++){
    clusters.push({ id:i, items:[i], height:0, left:null, right:null });
  }
  let nextId = n;

  function avgDist(aItems, bItems){
    let s=0, c=0;
    for (const i of aItems){
      for (const j of bItems){
        s += distMat[i][j];
        c++;
      }
    }
    return c ? s/c : 0;
  }

  while (clusters.length > 1){
    let bestI=0, bestJ=1, bestD=Infinity;
    for (let i=0;i<clusters.length;i++){
      for (let j=i+1;j<clusters.length;j++){
        const d = avgDist(clusters[i].items, clusters[j].items);
        if (d < bestD){
          bestD = d; bestI=i; bestJ=j;
        }
      }
    }
    const a = clusters[bestI];
    const b = clusters[bestJ];
    const merged = {
      id: nextId++,
      items: a.items.concat(b.items),
      height: bestD,
      left: a,
      right: b
    };
    clusters.splice(bestJ,1);
    clusters.splice(bestI,1);
    clusters.push(merged);
  }
  return clusters[0];
}
function dendrogramLeafOrder(node, out=[]){
  if (!node.left && !node.right){
    out.push(node.id);
    return out;
  }
  dendrogramLeafOrder(node.left, out);
  dendrogramLeafOrder(node.right, out);
  return out;
}
function computeHorizontalDendrogramSegments(root, leafOrder){
  const yPos = new Map();
  for (let i = 0; i < leafOrder.length; i++) yPos.set(leafOrder[i], i);

  const segX = [];
  const segY = [];

  function walk(node){
    if (!node.left && !node.right){
      return { x: 0, y: yPos.get(node.id) };
    }
    const L = walk(node.left);
    const R = walk(node.right);
    const x = node.height;

    segX.push(L.x, x, null); segY.push(L.y, L.y, null);
    segX.push(R.x, x, null); segY.push(R.y, R.y, null);
    segX.push(x, x, null);   segY.push(L.y, R.y, null);

    return { x, y: (L.y + R.y) / 2 };
  }
  walk(root);

  const maxH = root.height || 0;
  return { x: segX, y: segY, maxH };
}
function computePdbClustering(rows){
  if (!rows || rows.length < 2){
    return { orderedRows: rows ? rows.slice() : [], root:null, leafOrder:[] };
  }
  const vecs = rows.map(r=>rowVector01(r));
  const D = pairwiseDistanceMatrixFromVectors(vecs);
  const root = hclustAverage(D);
  const leafOrder = dendrogramLeafOrder(root, []);
  const orderedRows = leafOrder.map(i => rows[i]);
  return { orderedRows, root, leafOrder };
}

/* ===========================
   Most similar KLIFS pose (only PDB mode)
   =========================== */
function computeDockingBinaryFromFreq(){
  if (!dockFreqRow) return null;
  return klifsFeatureKeys.map(f => (Number(dockFreqRow[f])||0) >= 50 ? 1 : 0);
}
function findMostSimilarKlifsStructureToDocking(structRows){
  const dvec = computeDockingBinaryFromFreq();
  if (!dvec || !structRows?.length) return "";
  let bestLabel = "";
  let bestDist = Infinity;
  for (const r of structRows){
    const v = rowVector01(r);
    const d = jaccardDistanceVec(dvec, v);
    if (d < bestDist){
      bestDist = d;
      bestLabel = r.__labelFull || r.__label || "";
    }
  }
  return bestLabel;
}

/* ===========================
   PDB mode guard
   =========================== */
function guardPdbModeKinaseSelection(){
  const mode = viewModeSelect.value || "kinase";
  if (mode !== "pdb") return true;
  const picked = getSelectedValues();
  if (!picked.length){
    alert("PDB mode requires selecting at least one kinase in Selected list.");
    return false;
  }
  return true;
}

/* ===========================
   Aggregation for Family/Group rows
   =========================== */
function aggregateFreqRowsByScope(scope, value){
  const key = scope==="family" ? "FAMILY" : "GROUPS";
  const rows = klifsKinaseFreqRows.filter(r=>{
    const meta = lookupMetaForKinase(r[kinaseKeyName]);
    return meta[key] === value;
  });

  const out={};
  out[kinaseKeyName]=value;
  const nKinase = rows.length;
  const nStruct = rows.reduce((acc,r)=>acc+(Number(r.__n)||0),0);
  out.__n = nStruct;

  // short label you requested
  out.__label = `${value} (${nKinase}, ${nStruct})`;

  for (const f of klifsFeatureKeys){
    let sum=0, count=0;
    for (const r of rows){
      const v=Number(r[f]);
      if (Number.isFinite(v)){ sum+=v; count++; }
    }
    out[f] = count ? (sum/count) : 0;
  }
  return out;
}

/* ===========================
   KLIFS rows for heatmap (current selection)
   =========================== */
function getKlifsHeatmapRowsByCurrentSelection(){
  viewMode = viewModeSelect.value || "kinase";
  const picked = getSelectedValues();

  // non-PDB modes: never compute "most similar"
  if (viewMode !== "pdb"){
    lastKlifsHighlightedRowLabel = "";
  }

  if (viewMode==="kinase"){
    let base = klifsKinaseFreqRows.slice();
    if (picked.length){
      const set = new Set(picked);
      base = base.filter(r=>set.has(r[kinaseKeyName]));
    }
    return { rows: base, dendro:null };
  }

  if (viewMode==="family"){
    const fams = picked.length ? picked : familyList.slice();
    const rows = fams.map(f => aggregateFreqRowsByScope("family", f));
    rows.sort((a,b)=>String(a[kinaseKeyName]).localeCompare(String(b[kinaseKeyName])));
    return { rows, dendro:null };
  }

  if (viewMode==="group"){
    const grps = picked.length ? picked : groupList.slice();
    const rows = grps.map(g => aggregateFreqRowsByScope("group", g));
    rows.sort((a,b)=>String(a[kinaseKeyName]).localeCompare(String(b[kinaseKeyName])));
    return { rows, dendro:null };
  }

  // PDB MODE
  if (!guardPdbModeKinaseSelection()) return { rows: [], dendro:null };

  const kinase = picked[0];

  const structs = klifsStructBinaryRows
    .filter(r => safeTrim(r[kinaseKeyName]) === kinase)
    .map(r => ({...r}));

  const rows = structs.map(r=>{
    const out = {};
    out[kinaseKeyName] = kinase;
    out.structure_ID = r.structure_ID;

    const pdb = safeTrim(r.__pdb || alignmentPdbById.get(r.structure_ID) || "NA");
    const dfg = normalizeStateInOut(r.__dfg || "");
    const ac  = normalizeStateInOut(r.__alphac || "");

    out.__pdb = pdb;
    out.__dfg = dfg;
    out.__alphac = ac;
    out.__n = 1;

    out.__labelFull = `${kinase}/${pdb}/${dfg}/${ac}`;
    out.__label = out.__labelFull;

    for (const f of klifsFeatureKeys){
      out[f] = Number(r[f]) ? 100 : 0;
    }
    return out;
  });

  const cl = computePdbClustering(rows);
  const ordered = cl.orderedRows;

  if (residueModeActive && dockFreqRow && ordered.length >= 2){
    lastKlifsHighlightedRowLabel = findMostSimilarKlifsStructureToDocking(ordered);
  } else {
    lastKlifsHighlightedRowLabel = "";
  }

  const dendro = (cl.root && ordered.length >= 2)
    ? computeHorizontalDendrogramSegments(cl.root, cl.leafOrder)
    : null;

  return { rows: ordered, dendro };
}

/* ===========================
   KLIFS render
   =========================== */
runKlifsHeatmapBtn.addEventListener("click", ()=>{
  try{
    if (!(metaLoaded && klifsLoaded)) return;

    // ✅ PDB mode 必須至少選一個 kinase，否則直接擋掉（並顯示明確訊息）
    if (!guardPdbModeKinaseSelection()) return;

    const res = getKlifsHeatmapRowsByCurrentSelection();
    const rows = res.rows || [];
    lastKlifsRows = rows.slice();

    const klifsYLegend = document.getElementById("klifsYLegend");
    const modeNow = viewModeSelect.value || "kinase";

    if (modeNow === "pdb") {
      klifsYLegend.innerHTML =
        `Y label (PDB mode): <span class="pill">KINASE/PDB/DFG/alphaC</span> (example: CLK4/6FYV/in/in).`;
    } else if (modeNow === "family") {
      klifsYLegend.innerHTML =
        `Y label (Family mode): <span class="pill">FAMILY (nKinase, nStruct)</span> (example: CMGC (43, 864)).`;
    } else if (modeNow === "group") {
      klifsYLegend.innerHTML =
        `Y label (Group mode): <span class="pill">GROUP (nKinase, nStruct)</span> (example: CMGC (43, 864)).`;
    } else {
      klifsYLegend.innerHTML =
        `Y label (Kinase mode): <span class="pill">KINASE (nStruct)</span> (example: CLK4 (n=20)).`;
    }

    drawHeatmapFixedGutter({
      divId: "klifsHeatmap",
      rows,
      titleText: "KLIFS interaction frequency",
      featureMapForHover: residueModeActive ? residueFeatureMap : null,
      dendroSegments: res.dendro,
      highlightFullLabel: (modeNow==="pdb") ? lastKlifsHighlightedRowLabel : ""
    });

    // ✅ FIX: summaryInfo 可能不存在 → 防呆
    const picked = getSelectedValues();
    const summaryEl = document.getElementById("summaryInfo");
    if (summaryEl){
      summaryEl.innerHTML =
        `View mode <span class="pill">${modeNow}</span> ` +
        `Rows <span class="pill">${rows.length}</span> ` +
        (modeNow==="pdb"
          ? `Kinase <span class="pill">${picked[0] || ""}</span> <span class="pill">dendrogram reserved</span>`
          : `Selected <span class="pill">${picked.length ? picked.join(", ") : "All"}</span>`);
    }

  }catch(err){
    console.error(err);
    alert("KLIFS render failed: " + err.message);
  }
});


/* ===========================
   Docking processing
   =========================== */
const DOCK_KEYS = ["Pi-Hydrophobic","AlkylHydrophobic","MixedPiAlkylHydrophobic","HydrogenBond"];

function parseDockingInteractionColumn(colName){
  const s = String(colName||"");
  let kind=null;
  if (s.includes("HydrogenBond")) kind="HB";
  else if (s.includes("Pi-Hydrophobic") || s.includes("AlkylHydrophobic") || s.includes("MixedPiAlkylHydrophobic")) kind="HP";
  else return null;

  const m = s.match(/([A-Z]{3})(\d{1,5})/);
  if (!m) return null;
  const resNum = parseInt(m[2],10);
  if (!Number.isFinite(resNum)) return null;
  return { residueNumber: resNum, kind };
}

function inferDockingPdbFromDockTable(data2D){
  const header = (data2D[0] || []).map(safeTrim);
  const pdbIdx = findCol(header, ["pdb"]);
  if (pdbIdx < 0) return "";
  const counts = new Map();
  for (let r=1; r<data2D.length; r++){
    const row = data2D[r];
    if (!row) continue;
    const v = safeTrim(row[pdbIdx]);
    if (!v) continue;
    const key = normalizePdb(v);
    counts.set(key, (counts.get(key)||0)+1);
  }
  if (!counts.size) return "";
  let bestKey="", bestN=-1;
  for (const [k,n] of counts.entries()){
    if (n>bestN){ bestN=n; bestKey=k; }
  }
  return bestKey;
}

function processDockingPoseTable(data2D, sid){
  const header = (data2D[0] || []).map(safeTrim);
  const nameIdx = findCol(header, ["name","Name"]);
  if (nameIdx<0) throw new Error("Docking file must include column Name.");
  const dsIdx = findCol(header, ["r_i_docking_score","docking_score"]);

  const interactionCols=[];
  for (let c=0;c<header.length;c++){
    const h=header[c];
    if (!h) continue;
    if (DOCK_KEYS.some(k=>h.includes(k))){
      const p = parseDockingInteractionColumn(h);
      if (p) interactionCols.push({ idx:c, ...p });
    }
  }
  if (!interactionCols.length){
    throw new Error("No interaction columns found in docking table.");
  }

  const { resToKlifs } = buildResidueMapsByStructureId(sid);
  if (!resToKlifs.size){
    throw new Error("Residue to KLIFS mapping is empty for selected alignment row.");
  }

  const raw=[];
  for (let r=1;r<data2D.length;r++){
    const row=data2D[r];
    if (!row || row.every(v=>v==null || String(v).trim()==="")) continue;

    const name=safeTrim(row[nameIdx]);
    if (!name) continue;
    const ds = (dsIdx>=0) ? Number(row[dsIdx]) : NaN;

    const feat={};
    for (const ic of interactionCols){
      const val = Number(row[ic.idx]);
      const bin = Number.isFinite(val) && val >= 1 ? 1 : 0;
      if (!bin) continue;

      const klifsPos = resToKlifs.get(ic.residueNumber);
      if (!klifsPos) continue;
      feat[`${klifsPos}-${ic.kind}`] = 1;
    }
    raw.push({ Name:name, DS:ds, feat });
  }
  if (!raw.length) throw new Error("No valid docking rows found.");

  const best = new Map();
  for (const r of raw){
    if (!best.has(r.Name)) best.set(r.Name, r);
    else{
      const cur = best.get(r.Name);
      const curOk = Number.isFinite(cur.DS);
      const newOk = Number.isFinite(r.DS);
      if (!curOk && newOk) best.set(r.Name, r);
      else if (curOk && newOk && r.DS < cur.DS) best.set(r.Name, r);
    }
  }
  const uniq = Array.from(best.values());

  const featureSet = new Set(klifsFeatureKeys);
  const dockBinary = uniq.map(r=>{
    const out={ Name:r.Name, DS:r.DS };
    for (const f of featureSet) out[f]=0;
    for (const k of Object.keys(r.feat)){
      if (featureSet.has(k)) out[k]=1;
    }
    return out;
  });

  const freq={ __n:dockBinary.length, __label:`Docking (n=${dockBinary.length})` };
  for (const f of featureSet){
    let sum=0;
    for (const r of dockBinary) sum += Number(r[f]) ? 1 : 0;
    freq[f] = dockBinary.length ? (sum/dockBinary.length)*100 : 0;
  }

  return { dockBinary, freq };
}

/* ===========================
   Diff plot (FIXED: layout + thresholds + colors)
   =========================== */
function drawDiffPlot(dockFreq, klifsFreq, fmap){
  if (!dockFreq || !klifsFreq){
    Plotly.purge("diffPlot");
    return { items: [] };
  }

  let items = klifsFeatureKeys.map(f=>{
    const d = Number(dockFreq[f]) || 0;
    const k = Number(klifsFreq[f]) || 0;
    return { f, dock:d, klifs:k, diff:(d-k) };
  });

  items = items.filter(it => !(it.dock===0 && it.klifs===0));
  if (!items.length){
    Plotly.purge("diffPlot");
    return { items: [] };
  }

  // keep your sorting (by docking)
  items.sort((a,b)=>b.dock - a.dock);

  const x = items.map(it => (fmap?.get(it.f) || it.f));
  const yDock = items.map(it=>it.dock);
  const yKlifs = items.map(it=>it.klifs);
  const yDiff = items.map(it=>it.diff);

  // thresholds
  const dockThr = 50; // fixed ground-truth threshold (requested)
  const klifsThr = clamp01(klifsThresholdInput.value) * 100;

  const layout = {
    title: { text:"Docking vs KLIFS", y:0.98, x:0.5, xanchor:"center", yanchor:"top" },

    xaxis:{
      tickangle:-90,
      title: fmap ? "Features (aligned residue)" : "Features (raw key)",
      showgrid:false
    },

    yaxis:{ title:"Frequency percent", rangemode:"tozero" },
    yaxis2:{ title:"Delta (Docking − KLIFS)", overlaying:"y", side:"right" },

    barmode:"group",

    // Key fix: move legend to TOP, so it never covers x tick labels
    legend:{
      orientation:"h",
      x:0,
      y:1.10,
      xanchor:"left",
      yanchor:"bottom"
    },

    // Key fix: give more bottom room for long x labels
    margin:{ l:80, r:90, t:110, b:210 },

    height: 680,

    shapes: [
      // Docking 50% line (always)
      {
        type:"line",
        xref:"paper",
        x0:0, x1:1,
        yref:"y",
        y0:dockThr, y1:dockThr,
        line:{ color:getComputedStyle(document.documentElement).getPropertyValue('--c-thr-dock').trim() || "#b00020", width:2 }
      },
      // KLIFS threshold line (optional but useful)
      {
        type:"line",
        xref:"paper",
        x0:0, x1:1,
        yref:"y",
        y0:klifsThr, y1:klifsThr,
        line:{
          color:getComputedStyle(document.documentElement).getPropertyValue('--c-thr-klifs').trim() || "#0f766e",
          width:2,
          dash:"dash"
        }
      }
    ],

    annotations: [
      {
        xref:"paper", yref:"y", x:1.005, y:dockThr,
        text:"Docking 50%",
        showarrow:false,
        xanchor:"left",
        font:{ size:12, color:getComputedStyle(document.documentElement).getPropertyValue('--c-thr-dock').trim() || "#b00020" }
      },
      {
        xref:"paper", yref:"y", x:1.005, y:klifsThr,
        text:`KLIFS ${(klifsThr).toFixed(0)}%`,
        showarrow:false,
        xanchor:"left",
        font:{ size:12, color:getComputedStyle(document.documentElement).getPropertyValue('--c-thr-klifs').trim() || "#0f766e" }
      }
    ]
  };

  Plotly.newPlot("diffPlot", [
    {
      x, y:yDock, type:"bar", name:"Docking frequency",
      yaxis:"y1",
      marker:{ color:getComputedStyle(document.documentElement).getPropertyValue('--c-docking').trim() || "#374151" }
    },
    {
      x, y:yKlifs, type:"bar", name:"KLIFS frequency",
      yaxis:"y1",
      marker:{ color:getComputedStyle(document.documentElement).getPropertyValue('--c-klifs').trim() || "#0f766e" }
    },
    {
      x, y:yDiff, type:"scatter", mode:"lines+markers",
      name:"Delta Docking minus KLIFS", yaxis:"y2",
      line:{ color:getComputedStyle(document.documentElement).getPropertyValue('--c-delta').trim() || "#6d28d9", width:2 },
      marker:{ size:6, color:getComputedStyle(document.documentElement).getPropertyValue('--c-delta').trim() || "#6d28d9" }
    }
  ], layout, { responsive:true });

  return { items };
}

/* ===========================
   MDS + PERMANOVA (kept, colors improved)
   =========================== */
function jaccardDistance(a,b){
  let inter=0, uni=0;
  for (let i=0;i<a.length;i++){
    const ai=a[i]?1:0, bi=b[i]?1:0;
    if (ai||bi) uni++;
    if (ai&&bi) inter++;
  }
  if (!uni) return 0;
  return 1 - inter/uni;
}
function pairwiseDistanceMatrix(vectors){
  const n=vectors.length;
  const D=Array.from({length:n},()=>Array(n).fill(0));
  for (let i=0;i<n;i++){
    for (let j=i+1;j<n;j++){
      const d=jaccardDistance(vectors[i],vectors[j]);
      D[i][j]=d; D[j][i]=d;
    }
  }
  return D;
}
function permanovaTest(D, labels, nPerm=199){
  const n=labels.length;
  const uniq=Array.from(new Set(labels));

  function ssWithin(lbls){
    let ss=0;
    for (const g of uniq){
      const idx=[];
      for (let i=0;i<n;i++) if (lbls[i]===g) idx.push(i);
      if (idx.length<=1) continue;
      let sum=0;
      for (let a=0;a<idx.length;a++){
        for (let b=0;b<idx.length;b++){
          const d=D[idx[a]][idx[b]];
          sum += d*d;
        }
      }
      ss += sum / idx.length;
    }
    return ss;
  }
  function ssBetween(lbls){
    let sumAll=0;
    for (let i=0;i<n;i++){
      for (let j=0;j<n;j++){
        const d=D[i][j];
        sumAll += d*d;
      }
    }
    const grand = sumAll/(n*n);
    let ss=0;
    for (const g of uniq){
      const idx=[];
      for (let i=0;i<n;i++) if (lbls[i]===g) idx.push(i);
      if (!idx.length) continue;
      let sum=0;
      for (let a=0;a<idx.length;a++){
        for (let b=0;b<idx.length;b++){
          const d=D[idx[a]][idx[b]];
          sum += d*d;
        }
      }
      const mean = sum/(idx.length*idx.length);
      ss += idx.length*(mean-grand)*(mean-grand);
    }
    return ss;
  }

  const ssW=ssWithin(labels);
  const ssB=ssBetween(labels);
  const Fobs = ssB/(ssW+1e-12);

  let count=0;
  for (let p=0;p<nPerm;p++){
    const perm=labels.slice();
    for (let i=n-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [perm[i],perm[j]]=[perm[j],perm[i]];
    }
    const Fp = ssBetween(perm)/(ssWithin(perm)+1e-12);
    if (Fp>=Fobs) count++;
  }
  const pval=(count+1)/(nPerm+1);
  return { F:Fobs, p:pval };
}
function mds2DFromDistance(D){
  const n=D.length;
  const D2=Array.from({length:n},()=>Array(n).fill(0));
  for (let i=0;i<n;i++) for (let j=0;j<n;j++) D2[i][j]=D[i][j]*D[i][j];

  const rowMean=Array(n).fill(0), colMean=Array(n).fill(0);
  for (let i=0;i<n;i++){
    let s=0; for (let j=0;j<n;j++) s+=D2[i][j];
    rowMean[i]=s/n;
  }
  for (let j=0;j<n;j++){
    let s=0; for (let i=0;i<n;i++) s+=D2[i][j];
    colMean[j]=s/n;
  }
  const grand = rowMean.reduce((a,b)=>a+b,0)/n;

  const B=Array.from({length:n},()=>Array(n).fill(0));
  for (let i=0;i<n;i++){
    for (let j=0;j<n;j++){
      B[i][j] = -0.5*(D2[i][j]-rowMean[i]-colMean[j]+grand);
    }
  }

  function matVec(M,v){
    const out=Array(M.length).fill(0);
    for (let i=0;i<M.length;i++){
      let s=0; for (let j=0;j<M.length;j++) s+=M[i][j]*v[j];
      out[i]=s;
    }
    return out;
  }
  function dot(a,b){ let s=0; for (let i=0;i<a.length;i++) s+=a[i]*b[i]; return s; }
  function norm(a){ return Math.sqrt(dot(a,a)) || 1; }
  function scale(a,k){ return a.map(x=>x*k); }

  function powerIter(M, it=220){
    let v=Array(M.length).fill(0).map(()=>Math.random()-0.5);
    v=scale(v, 1/norm(v));
    for (let t=0;t<it;t++){
      const w=matVec(M,v);
      v=scale(w, 1/norm(w));
    }
    const w=matVec(M,v);
    const lambda=dot(v,w);
    return { lambda, v };
  }

  const e1=powerIter(B,260);
  const B2=Array.from({length:n},(_,i)=>Array.from({length:n},(_,j)=>B[i][j]-e1.lambda*e1.v[i]*e1.v[j]));
  const e2=powerIter(B2,260);

  const l1=Math.max(e1.lambda,0), l2=Math.max(e2.lambda,0);
  const x=e1.v.map(v=>v*Math.sqrt(l1));
  const y=e2.v.map(v=>v*Math.sqrt(l2));
  return { x,y };
}
function drawMds(vectors, labels){
  if (vectors.length < 3){
    Plotly.purge("mdsPlot");
    return { perma:null, note:"Insufficient samples for MDS and PERMANOVA." };
  }
  const cMdsKlifs = getComputedStyle(document.documentElement)
    .getPropertyValue("--c-mds-klifs")
    .trim() || "#6b5458";
  const cMdsDock = getComputedStyle(document.documentElement)
    .getPropertyValue("--c-mds-docking")
    .trim() || "#68945c";

  const D = pairwiseDistanceMatrix(vectors);
  const perma = permanovaTest(D, labels, 199);
  const mds = mds2DFromDistance(D);

  const xK=[], yK=[], xD=[], yD=[];
  for (let i=0;i<labels.length;i++){
    if (labels[i]==="KLIFS"){ xK.push(mds.x[i]); yK.push(mds.y[i]); }
    else { xD.push(mds.x[i]); yD.push(mds.y[i]); }
  }

  Plotly.newPlot("mdsPlot", [
  {
    x:xK, y:yK,
    type:"scatter",
    mode:"markers",
    name:`KLIFS (n=${xK.length})`,
    marker:{
      size:11,
      symbol:"triangle-up",
      color: cMdsKlifs,
      line:{ color:"#0b2f2a", width:1 }
    },
    opacity:0.70
  },
  {
    x:xD, y:yD,
    type:"scatter",
    mode:"markers",
    name:`Docking (n=${xD.length})`,
    marker:{
      size:9,
      color: cMdsDock,
      line:{ color:"#ffffff", width:1 }
    },
    opacity:0.70
  }
], {
  title:"MDS with Jaccard distance",
  xaxis:{ title:"Dimension 1" },
  yaxis:{ title:"Dimension 2" },
  margin:{ l:70, r:20, t:50, b:50 },
  height:620,
  legend:{ orientation:"h" }
}, { responsive:true });

  return { perma };
}

/* ===========================
   Confusion matrix (kept)
   =========================== */
function computeConfusion(dockFreq, klifsFreq, klifsThreshold){
  const thr = clamp01(klifsThreshold) * 100;
  let TP=0, FP=0, TN=0, FN=0;

  const rows = [];
  for (const f of klifsFeatureKeys){
    const d = Number(dockFreq?.[f]) || 0;
    const k = Number(klifsFreq?.[f]) || 0;

    const truthPos = d >= 50;
    const testPos  = k >= thr;

    if (truthPos && testPos) TP++;
    else if (!truthPos && testPos) FP++;
    else if (!truthPos && !testPos) TN++;
    else FN++;

    rows.push({ feature:f, docking_freq:d, klifs_freq:k, truth: truthPos?1:0, pred: testPos?1:0 });
  }

  const precision = (TP+FP) ? TP/(TP+FP) : null;
  const recall    = (TP+FN) ? TP/(TP+FN) : null;
  const specificity = (TN+FP) ? TN/(TN+FP) : null;
  const accuracy = (TP+TN+FP+FN) ? (TP+TN)/(TP+TN+FP+FN) : null;
  const f1 = (precision!=null && recall!=null && (precision+recall)>0) ? (2*precision*recall/(precision+recall)) : null;

  return { TP, FP, TN, FN, precision, recall, specificity, accuracy, f1, thrPercent: thr, perFeature: rows };
}

function drawConfusionPlot(conf){
  if (!conf){
    Plotly.purge("confusionPlot");
    return;
  }

  const z = [[0,0],[0,0]];
  const x = ["Pred −", "Pred +"];
  const y = ["True −", "True +"];
  const white = [[0, "#ffffff"], [1, "#ffffff"]];

  const fmt = (v)=> (v==null ? "NA" : v.toFixed(3));
  const metricLines = [
    `KLIFS thr ${conf.thrPercent.toFixed(1)}%`,
    `Prec ${conf.precision==null ? "NA" : fmt(conf.precision)}`,
    `Rec ${conf.recall==null ? "NA" : fmt(conf.recall)}`,
    `Spec ${conf.specificity==null ? "NA" : fmt(conf.specificity)}`,
    `Acc ${conf.accuracy==null ? "NA" : fmt(conf.accuracy)}`,
    `F1 ${conf.f1==null ? "NA" : fmt(conf.f1)}`
  ].join("<br>");

  const cellAnn = [
    { x:"Pred −", y:"True −", text:`TN ${conf.TN}` },
    { x:"Pred +", y:"True −", text:`FP ${conf.FP}` },
    { x:"Pred −", y:"True +", text:`FN ${conf.FN}` },
    { x:"Pred +", y:"True +", text:`TP ${conf.TP}` },
  ].map(a => ({
    xref:"x", yref:"y",
    x:a.x, y:a.y,
    text: a.text,
    showarrow:false,
    font:{ size:16, color:"#111111" }
  }));

  const metricAnn = {
    xref:"paper", yref:"paper", x:1.02, y:0.98, xanchor:"left", yanchor:"top",
    text: metricLines,
    showarrow:false,
    align:"left",
    font:{ size:16, color:"#333333" }
  };

  Plotly.newPlot("confusionPlot", [{
    x,y,z,
    type:"heatmap",
    colorscale:white,
    zmin:0, zmax:1,
    showscale:false,
    hoverinfo:"skip"
  }], {
    title:"Confusion matrix",
    xaxis:{
      range:[-0.5, 1.5],
      tickmode:"array",
      tickvals:[0,1],
      ticktext:["Pred −","Pred +"],
      showgrid:false,
      zeroline:false,
      showline:true,
      linecolor:"#111111",
      linewidth:1
    },
    yaxis:{
      range:[-0.5, 1.5],
      tickmode:"array",
      tickvals:[0,1],
      ticktext:["True −","True +"],
      showgrid:false,
      zeroline:false,
      showline:true,
      linecolor:"#111111",
      linewidth:1
    },
    shapes: [
      { type:"rect", xref:"x", yref:"y",
        x0:-0.5, x1:1.5, y0:-0.5, y1:1.5,
        line:{ color:"#111111", width:2 }, fillcolor:"rgba(0,0,0,0)"
      },
      { type:"line", xref:"x", yref:"y",
        x0:0.5, x1:0.5, y0:-0.5, y1:1.5,
        line:{ color:"#111111", width:1 }
      },
      { type:"line", xref:"x", yref:"y",
        x0:-0.5, x1:1.5, y0:0.5, y1:0.5,
        line:{ color:"#111111", width:1 }
      }
    ],
    annotations: [...cellAnn, metricAnn],
    margin:{ l:90, r:220, t:60, b:60 },
    height:360
  }, { responsive:true });
}

/* ===========================
   Compare recompute
   =========================== */
function recomputeAllCompareOutputs(){
  if (!residueModeActive || !dockFreqRow) return;

  const scope = getCurrentSelectionScope();
  const klifsStruct = filterKlifsStructBinaryByScope(scope);
  const klifsFreq = freqFromBinaryRows(klifsStruct, `KLIFS ${scope.mode} ${scope.items.join("+")}`);

  const diffRes = drawDiffPlot(dockFreqRow, klifsFreq, residueFeatureMap);

  const klifsVec = klifsStruct.map(r=>klifsFeatureKeys.map(f=>Number(r[f])?1:0));
  const dockVec  = dockBinaryRows.map(r=>klifsFeatureKeys.map(f=>Number(r[f])?1:0));
  const vectors=[], labels=[];
  for (const v of klifsVec){ vectors.push(v); labels.push("KLIFS"); }
  for (const v of dockVec){ vectors.push(v); labels.push("Docking"); }
  const mdsRes = drawMds(vectors, labels);

  const thr = clamp01(klifsThresholdInput.value);
  const conf = computeConfusion(dockFreqRow, klifsFreq, thr);
  drawConfusionPlot(conf);

  // PERMANOVA / X-axis / hover 說明全部不顯示
  const summaryEl = document.getElementById("summaryInfo");
  if (summaryEl){
    summaryEl.innerHTML =
      `Compare <span class="pill">Aligned</span> ` +
      `Alignment <span class="pill">${lastDockAlignmentSid}</span> ` +
      `Docking ligands <span class="pill">${dockFreqRow.__n}</span> ` +
      `KLIFS structures <span class="pill">${klifsStruct.length}</span>`;
  }


  lastCompare.dockingPdb = safeTrim(dockPdbInput.value) || inferDockingPdbFromDockTable(dockRaw2D) || "";
  lastCompare.alignmentSid = lastDockAlignmentSid;
  lastCompare.compareMode = scope.mode;
  lastCompare.compareSelectedLabel = scope.label;
  lastCompare.klifsStructCount = klifsStruct.length;
  lastCompare.dockingLigCount = dockFreqRow.__n;
  lastCompare.permanovaF = mdsRes?.perma ? mdsRes.perma.F : null;
  lastCompare.permanovaP = mdsRes?.perma ? mdsRes.perma.p : null;
  lastCompare.confusion = conf;

  return { klifsStruct, klifsFreq, diffItems: diffRes.items, perma: mdsRes.perma, conf };
}

/* ===========================
   Compare (PDB-driven)
   =========================== */
compareBtn.addEventListener("click", ()=>{
  try{
    if (!(metaLoaded && klifsLoaded && alignLoaded && dockLoaded)){
      alert("Compare requires Meta, KLIFS IFP, alignment, and docking files.");
      return;
    }

    const manualPdb = safeTrim(dockPdbInput.value);
    const inferredPdbNorm = inferDockingPdbFromDockTable(dockRaw2D);
    const pdbToUse = manualPdb ? manualPdb : inferredPdbNorm;

    if (!pdbToUse){
      alert('Please enter Docking PDB (e.g., 6FYV), or include a "pdb" column in docking file for auto inference.');
      return;
    }

    const sid = autoPickAlignmentStructureIdForPdb(pdbToUse);
    if (!sid){
      alert(`Alignment row not found for PDB "${pdbToUse}". Check alignment file column "pdb" and values.`);
      return;
    }
    lastDockAlignmentSid = sid;

    residueModeActive = true;
    residueFeatureMap = buildResidueFeatureMapFromSid(sid);

    const proc = processDockingPoseTable(dockRaw2D, sid);
    dockBinaryRows = proc.dockBinary;
    dockFreqRow = proc.freq;

    // redraw KLIFS heatmap
    const res = getKlifsHeatmapRowsByCurrentSelection();
    lastKlifsRows = (res.rows || []).slice();

    drawHeatmapFixedGutter({
      divId: "klifsHeatmap",
      rows: res.rows || [],
      titleText: "KLIFS interaction frequency",
      featureMapForHover: residueFeatureMap,
      dendroSegments: res.dendro,
      highlightFullLabel: (viewModeSelect.value==="pdb") ? lastKlifsHighlightedRowLabel : ""
    });

    drawHeatmapFixedGutter({
      divId: "dockHeatmap",
      rows: [dockFreqRow],
      titleText: "Docking interaction frequency (aligned)",
      featureMapForHover: residueFeatureMap,
      dendroSegments: null,
      highlightFullLabel: ""
    });

    // stats
    recomputeAllCompareOutputs();

  }catch(err){
    console.error(err);
    alert("Compare failed: " + err.message);
  }finally{
    refreshUiLocks();
  }
});

// Apply threshold
applyThresholdBtn.addEventListener("click", ()=>{
  if (!residueModeActive || !dockFreqRow) return;
  recomputeAllCompareOutputs();
});
klifsThresholdInput.addEventListener("keydown", (e)=>{
  if (e.key === "Enter"){
    e.preventDefault();
    applyThresholdBtn.click();
  }
});

/* ===========================
   Export Excel and plots (kept)
   =========================== */
function buildHeatmapTable(rows, fmap){
  const out = [];
  for (const r of rows){
    const rowObj = { Row: r.__label ?? r[kinaseKeyName] ?? "row" };
    if (r.__pdb!=null || r.structure_ID!=null){
      rowObj.PDB = r.__pdb || "";
      rowObj.structure_ID = r.structure_ID || "";
    }
    for (let i=0;i<klifsFeatureKeys.length;i++){
      const f = klifsFeatureKeys[i];
      const label = fmap?.get(f) || f;
      rowObj[label] = Number(r[f]) || 0;
    }
    out.push(rowObj);
  }
  return out;
}

exportExcelBtn.addEventListener("click", ()=>{
  try{
    if (!residueModeActive || !dockFreqRow) return;

    const scope = getCurrentSelectionScope();
    const klifsStruct = filterKlifsStructBinaryByScope(scope);
    const klifsFreq = freqFromBinaryRows(klifsStruct, `KLIFS ${scope.mode} ${scope.items.join("+")}`);
    const diffRes = drawDiffPlot(dockFreqRow, klifsFreq, residueFeatureMap);

    const thr = clamp01(klifsThresholdInput.value);
    const conf = computeConfusion(dockFreqRow, klifsFreq, thr);

    const wb = XLSX.utils.book_new();

    const klifsSheetData = buildHeatmapTable(
      Array.isArray(lastKlifsRows) ? lastKlifsRows : [],
      residueFeatureMap
    );
    const ws1 = XLSX.utils.json_to_sheet(klifsSheetData);
    XLSX.utils.book_append_sheet(wb, ws1, "KLIFS_heatmap");

    const dockSheetData = buildHeatmapTable([dockFreqRow], residueFeatureMap);
    const ws2 = XLSX.utils.json_to_sheet(dockSheetData);
    XLSX.utils.book_append_sheet(wb, ws2, "Docking_heatmap");

    const diffData = (diffRes.items || []).map(it=>({
      Feature_raw: it.f,
      Feature_residue: residueFeatureMap.get(it.f) || it.f,
      Docking_frequency_percent: it.dock,
      KLIFS_frequency_percent: it.klifs,
      Delta_docking_minus_klifs: it.diff
    }));
    const ws3 = XLSX.utils.json_to_sheet(diffData);
    XLSX.utils.book_append_sheet(wb, ws3, "Diff_table");

    const metrics = [{
      Docking_PDB: safeTrim(dockPdbInput.value) || inferDockingPdbFromDockTable(dockRaw2D) || "",
      View_mode: scope.mode,
      Selected_items: scope.items.join("+"),
      Alignment_structure_ID: lastDockAlignmentSid,
      Docking_ligands: dockFreqRow.__n,
      KLIFS_structures: klifsStruct.length,
      KLIFS_threshold_percent: conf.thrPercent,
      TP: conf.TP, FP: conf.FP, TN: conf.TN, FN: conf.FN,
      Precision: conf.precision,
      Recall: conf.recall,
      Specificity: conf.specificity,
      Accuracy: conf.accuracy,
      F1: conf.f1,
      PERMANOVA_F: lastCompare.permanovaF,
      PERMANOVA_p: lastCompare.permanovaP
    }];
    const ws4 = XLSX.utils.json_to_sheet(metrics);
    XLSX.utils.book_append_sheet(wb, ws4, "Metrics");

    const perFeat = conf.perFeature.map(r=>({
      Feature_raw: r.feature,
      Feature_residue: residueFeatureMap.get(r.feature) || r.feature,
      Docking_frequency_percent: r.docking_freq,
      KLIFS_frequency_percent: r.klifs_freq,
      Truth_positive: r.truth,
      Predicted_positive: r.pred
    }));
    const ws5 = XLSX.utils.json_to_sheet(perFeat);
    XLSX.utils.book_append_sheet(wb, ws5, "Feature_labels");

    const filename = `${makeBaseExportName()}.xlsx`;
    XLSX.writeFile(wb, filename);

  }catch(err){
    console.error(err);
    alert("Excel export failed: " + err.message);
  }
});

async function exportPlotDiv(divId, filename){
  const gd = document.getElementById(divId);
  if (!gd || !gd.data || !gd.data.length) return;
  const url = await Plotly.toImage(gd, { format:"png", height: gd.layout?.height || 720, width: 1400, scale: 2 });
  downloadDataUrl(url, filename);
}

exportPlotsBtn.addEventListener("click", async ()=>{
  try{
    if (!residueModeActive || !dockFreqRow) return;
    const base = makeBaseExportName();
    await exportPlotDiv("klifsHeatmap", `${base}__KLIFS_heatmap.png`);
    await exportPlotDiv("dockHeatmap",  `${base}__Docking_heatmap.png`);
    await exportPlotDiv("diffPlot",     `${base}__Diff_plot.png`);
    await exportPlotDiv("mdsPlot",      `${base}__MDS.png`);
    await exportPlotDiv("confusionPlot",`${base}__Confusion.png`);
  }catch(err){
    console.error(err);
    alert("Plot export failed: " + err.message);
  }
});

/* ===========================
   Reset (do NOT clear manual Docking PDB)
   =========================== */
function resetWorkflowState(){
  viewModeSelect.value = "kinase";
  // Hide selection summary block (x axis / hover / permanova note)
  document.getElementById("dataPanel")?.classList.add("hide-selection-summary");

  selectedList.innerHTML = "";
  rebuildAvailableSelectedLists(true);

  Plotly.purge("klifsHeatmap");
  Plotly.purge("dockHeatmap");
  Plotly.purge("diffPlot");
  Plotly.purge("mdsPlot");
  Plotly.purge("confusionPlot");

  summaryInfo.innerHTML = "";

  lastKlifsRows = [];
  residueModeActive = false;
  residueFeatureMap = new Map();
  dockBinaryRows = [];
  dockFreqRow = null;
  lastDockAlignmentSid = "";

  lastCompare = {
    dockingPdb: "",
    alignmentSid: "",
    compareMode: "",
    compareSelectedLabel: "",
    klifsStructCount: 0,
    dockingLigCount: 0,
    permanovaF: null,
    permanovaP: null,
    confusion: null,
  };

  lastKlifsHighlightedRowLabel = "";

  setStatus("Reset complete. Files remain loaded.");
  refreshUiLocks();
}

resetBtn.addEventListener("click", ()=>{
  if (!(metaLoaded && klifsLoaded)) return;
  resetWorkflowState();
});

/* ===========================
   Init
   =========================== */
viewModeSelect.value = "kinase";
refreshUiLocks();
rebuildAvailableSelectedLists(true);
</script>
</body>
</html>
