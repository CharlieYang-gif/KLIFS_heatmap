<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Kinase IFP Heatmap Tool (KLIFS + Docking Compare)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      --bg:#f5f5f5;
      --panel:#ffffff;
      --text:#222;
      --muted:#666;
      --primary:#1f7ae0;
      --primary-dark:#155cb0;
      --border:#e6e6e6;
      --border-strong:#b8c7e6;
      --danger:#b42318;
      --ok:#2e7d32;
      --pill-bg:#eef4ff;
      --shadow:0 2px 10px rgba(0,0,0,0.08);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans", "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    body{
      margin:0;
      font-family: var(--sans);
      background: var(--bg);
      color: var(--text);
    }

    .wrap{
      max-width: 1280px;
      margin: 24px auto 40px;
      padding: 0 16px;
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 18px;
      align-items: start;
    }

    .panel{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .panel-header{
      padding: 14px 14px 10px;
      border-bottom: 1px solid var(--border);
    }

    .panel-header h1{
      font-size: 16px;
      margin: 0 0 4px;
      letter-spacing: 0.2px;
    }

    .panel-header p{
      margin: 0;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }

    .panel-body{
      padding: 14px;
      display: grid;
      gap: 12px;
    }

    .row{
      display: grid;
      gap: 8px;
    }

    label{
      font-size: 12px;
      color: var(--muted);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    input[type="file"], select, input[type="number"], input[type="text"]{
      width: 100%;
      padding: 10px 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      font-size: 13px;
      outline: none;
    }

    select[multiple]{
      min-height: 120px;
      padding: 10px;
    }

    .hint{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.45;
    }

    .inline{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .toggle{
      display:flex;
      gap:8px;
      flex-wrap: wrap;
    }

    .pill{
      user-select: none;
      cursor: pointer;
      font-size: 12px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #fff;
      color: var(--text);
    }
    .pill.active{
      background: var(--pill-bg);
      border-color: var(--border-strong);
      color: var(--primary-dark);
      font-weight: 600;
    }

    .btns{
      display:flex;
      gap:10px;
    }

    button{
      cursor: pointer;
      border: 0;
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 13px;
      font-weight: 600;
    }

    .btn-primary{
      background: var(--primary);
      color: #fff;
    }
    .btn-primary:hover{ background: var(--primary-dark); }

    .btn-ghost{
      background: #fff;
      color: var(--text);
      border: 1px solid var(--border);
    }

    .alert{
      display:none;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(180,35,24,0.25);
      background: rgba(180,35,24,0.08);
      color: var(--danger);
      font-size: 12px;
      line-height: 1.35;
    }
    .alert.show{ display:block; }

    .status{
      font-size: 12px;
      color: var(--muted);
    }

    .main{
      display: grid;
      gap: 18px;
    }

    .viz{
      padding: 12px;
    }

    .viz .titlebar{
      display:flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
      padding: 8px 10px 12px;
    }

    .viz .titlebar h2{
      margin: 0;
      font-size: 14px;
    }

    .viz .titlebar .meta{
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 55ch;
    }

    #heatmap{
      width: 100%;
      height: 620px;
    }

    /* 這個區塊只是用來示意 docking pose 可對齊的下方區域 */
    .docking-placeholder{
      border-top: 1px solid var(--border);
      padding: 12px 10px 14px;
      display: grid;
      gap: 8px;
    }
    .docking-placeholder .bar{
      height: 10px;
      background: linear-gradient(90deg, rgba(31,122,224,0.15), rgba(31,122,224,0));
      border-radius: 999px;
    }
    .docking-placeholder .note{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.45;
    }

    @media (max-width: 980px){
      .wrap{ grid-template-columns: 1fr; }
      #heatmap{ height: 560px; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <!-- Left control panel -->
    <div class="panel">
      <div class="panel-header">
        <h1>KLIFS IFP Heatmap Tool</h1>
        <p>支援 Excel 輸入、PDB 模式篩選、與 docking pose 對齊用的短 y 軸標籤。</p>
      </div>

      <div class="panel-body">
        <div id="alert" class="alert"></div>

        <div class="row">
          <label>上傳 Excel（.xlsx）</label>
          <input id="file" type="file" accept=".xlsx,.xls" />
          <div class="hint">
            預期欄位包含：<span style="font-family:var(--mono)">kinase / pdb / structure_ID / IFP_*</span>（你原本的格式即可）。
          </div>
        </div>

        <div class="row">
          <label>模式</label>
          <div class="toggle">
            <div class="pill active" id="modeKinase">kinase</div>
            <div class="pill" id="modePdb">pdb</div>
          </div>
          <div class="hint">
            - <b>kinase 模式</b>：y 軸以 kinase 分組呈現<br/>
            - <b>pdb 模式</b>：y 軸以 pdb（或 structure）呈現，並可強制至少選一個 kinase 作為過濾
          </div>
        </div>

        <div class="row">
          <label>
            Kinase 篩選（多選）
            <span class="status" id="kinaseCount">0 selected</span>
          </label>
          <select id="kinaseSelect" multiple></select>
          <div class="hint">
            <b>PDB 模式下將強制至少選一個 kinase。</b><br/>
            小技巧：Windows 按住 Ctrl；macOS 按住 Command 可多選。
          </div>
        </div>

        <div class="row">
          <label>Y 軸標籤最大長度（用於對齊 docking pose）</label>
          <div class="inline">
            <input id="yMaxLen" type="number" min="6" max="48" step="1" value="14" />
            <select id="yShortPolicy">
              <option value="tail" selected>保留尾端（…XYZ）</option>
              <option value="head">保留前端（ABC…）</option>
              <option value="middle">中間截斷（AB…YZ）</option>
            </select>
          </div>
          <div class="hint">
            建議 10–18。越短越容易和下方 docking pose 區域視覺對齊。
          </div>
        </div>

        <div class="row">
          <label>Plot 設定</label>
          <div class="inline">
            <input id="cellSize" type="number" min="6" max="40" step="1" value="16" />
            <input id="leftMargin" type="number" min="80" max="260" step="5" value="140" />
          </div>
          <div class="hint">
            <span style="font-family:var(--mono)">cellSize</span> 影響格子大小；
            <span style="font-family:var(--mono)">leftMargin</span> 影響 y 軸區域寬度（對齊 docking pose 時很關鍵）。
          </div>
        </div>

        <div class="btns">
          <button class="btn-primary" id="renderBtn">Render Heatmap</button>
          <button class="btn-ghost" id="resetBtn">Reset</button>
        </div>

        <div class="row">
          <div class="status" id="status">尚未載入資料</div>
        </div>
      </div>
    </div>

    <!-- Right visualization -->
    <div class="panel main">
      <div class="viz">
        <div class="titlebar">
          <h2>Heatmap</h2>
          <div class="meta" id="meta"></div>
        </div>
        <div id="heatmap"></div>

        <!-- Docking pose placeholder area (align-friendly) -->
        <div class="docking-placeholder">
          <div class="bar"></div>
          <div class="note">
            下方區塊預留給 docking pose 視覺化（例如 NGL / Mol* / 自製 SVG）。<br/>
            本版的 y 軸會使用短標籤與固定 left margin，讓 heatmap 更容易和下方 pose 對齊。
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
  /******************************************************************
   * State
   ******************************************************************/
  const state = {
    mode: "kinase",          // "kinase" | "pdb"
    rows: [],                // parsed rows (objects)
    ifpCols: [],             // ["IFP_0","IFP_1",...]
    kinaseList: [],          // unique kinases
    pdbList: [],             // unique pdbs / structures
    loadedFileName: "",
  };

  /******************************************************************
   * DOM
   ******************************************************************/
  const $ = (id) => document.getElementById(id);

  const fileEl = $("file");
  const renderBtn = $("renderBtn");
  const resetBtn = $("resetBtn");

  const modeKinase = $("modeKinase");
  const modePdb = $("modePdb");

  const kinaseSelect = $("kinaseSelect");
  const kinaseCount = $("kinaseCount");

  const yMaxLen = $("yMaxLen");
  const yShortPolicy = $("yShortPolicy");
  const cellSize = $("cellSize");
  const leftMargin = $("leftMargin");

  const alertEl = $("alert");
  const statusEl = $("status");
  const metaEl = $("meta");

  /******************************************************************
   * Utilities
   ******************************************************************/
  function showAlert(msg){
    alertEl.textContent = msg;
    alertEl.classList.add("show");
  }
  function clearAlert(){
    alertEl.textContent = "";
    alertEl.classList.remove("show");
  }
  function setStatus(msg){
    statusEl.textContent = msg;
  }

  function uniq(arr){
    return Array.from(new Set(arr.filter(v => v !== undefined && v !== null && String(v).trim() !== "")));
  }

  function getSelectedValues(selectEl){
    return Array.from(selectEl.selectedOptions).map(o => o.value);
  }

  function shortenLabel(s, maxLen, policy){
    const str = String(s ?? "");
    if (maxLen <= 0) return "";
    if (str.length <= maxLen) return str;

    const ell = "…";
    if (maxLen <= 1) return ell;

    if (policy === "head"){
      // ABC…
      return str.slice(0, maxLen - 1) + ell;
    }
    if (policy === "tail"){
      // …XYZ
      return ell + str.slice(str.length - (maxLen - 1));
    }
    // middle: AB…YZ
    const keep = maxLen - 1;
    const left = Math.ceil(keep / 2);
    const right = Math.floor(keep / 2);
    return str.slice(0, left) + ell + str.slice(str.length - right);
  }

  function detectColumns(rowObj){
    const keys = Object.keys(rowObj || {});
    const ifps = keys.filter(k => /^IFP_/i.test(k)).sort((a,b) => {
      // numeric-aware sort: IFP_2 before IFP_10
      const na = Number(String(a).split("_")[1]);
      const nb = Number(String(b).split("_")[1]);
      if (Number.isFinite(na) && Number.isFinite(nb)) return na - nb;
      return a.localeCompare(b);
    });
    return ifps;
  }

  function safeGet(row, candidates){
    for (const c of candidates){
      if (row && row[c] !== undefined && row[c] !== null && String(row[c]).trim() !== "") return row[c];
    }
    return "";
  }

  /******************************************************************
   * Mode switching
   ******************************************************************/
  function setMode(nextMode){
    state.mode = nextMode;
    if (nextMode === "kinase"){
      modeKinase.classList.add("active");
      modePdb.classList.remove("active");
    } else {
      modePdb.classList.add("active");
      modeKinase.classList.remove("active");
    }
    // 不強迫清空選擇，但 PDB 模式 render 時會 guard
    clearAlert();
    updateMeta();
  }

  modeKinase.addEventListener("click", () => setMode("kinase"));
  modePdb.addEventListener("click", () => setMode("pdb"));

  /******************************************************************
   * File parsing
   ******************************************************************/
  fileEl.addEventListener("change", async (e) => {
    clearAlert();
    const file = e.target.files?.[0];
    if (!file){
      setStatus("未選擇檔案");
      return;
    }

    state.loadedFileName = file.name;
    setStatus(`讀取檔案中：${file.name}`);

    try{
      const data = await file.arrayBuffer();
      const wb = XLSX.read(data, { type: "array" });

      const firstSheetName = wb.SheetNames[0];
      const ws = wb.Sheets[firstSheetName];

      // defval: keep empty cells
      const json = XLSX.utils.sheet_to_json(ws, { defval: "" });

      if (!json || json.length === 0){
        state.rows = [];
        state.ifpCols = [];
        state.kinaseList = [];
        state.pdbList = [];
        rebuildKinaseSelect();
        setStatus("Excel 沒有可用資料列");
        return;
      }

      state.rows = json;
      state.ifpCols = detectColumns(json[0]);

      // detect kinase / pdb columns (support multiple naming)
      const kinases = uniq(json.map(r => safeGet(r, ["kinase", "Kinase", "KINASE", "target", "Target"])));
      const pdbs    = uniq(json.map(r => safeGet(r, ["pdb", "PDB", "structure_ID", "structureId", "Structure_ID", "complex", "Complex"])));

      state.kinaseList = kinases.sort((a,b) => String(a).localeCompare(String(b)));
      state.pdbList = pdbs.sort((a,b) => String(a).localeCompare(String(b)));

      rebuildKinaseSelect();

      setStatus(`載入完成：${json.length} rows, ${state.ifpCols.length} IFP columns`);
      updateMeta();

      // 初次載入：直接 render 一次（不做 PDB 模式 guard，因為預設是 kinase 模式）
      renderHeatmap();

    }catch(err){
      console.error(err);
      showAlert(`讀取失敗：${err?.message || err}`);
      setStatus("讀取失敗");
    }
  });

  function rebuildKinaseSelect(){
    kinaseSelect.innerHTML = "";
    state.kinaseList.forEach(k => {
      const opt = document.createElement("option");
      opt.value = String(k);
      opt.textContent = String(k);
      kinaseSelect.appendChild(opt);
    });
    updateKinaseCount();
  }

  kinaseSelect.addEventListener("change", updateKinaseCount);
  function updateKinaseCount(){
    const n = getSelectedValues(kinaseSelect).length;
    kinaseCount.textContent = `${n} selected`;
  }

  /******************************************************************
   * Guard: PDB mode must select at least one kinase
   * - 你提到「想加的話我也可以給你一行 guard」：此處已內建。
   ******************************************************************/
  function guardPdbModeSelection(){
    if (state.mode !== "pdb") return true;
    const selectedKinases = getSelectedValues(kinaseSelect);
    if (selectedKinases.length < 1){
      showAlert("PDB 模式下請至少選擇 1 個 kinase（用來過濾資料）。");
      return false;
    }
    return true;
  }

  /******************************************************************
   * Transform data -> matrix for Plotly
   ******************************************************************/
  function buildMatrix(){
    const ifpCols = state.ifpCols;
    const rows = state.rows;

    // column detection
    const getKinase = (r) => String(safeGet(r, ["kinase","Kinase","KINASE","target","Target"]) || "");
    const getPdb    = (r) => String(safeGet(r, ["pdb","PDB","structure_ID","structureId","Structure_ID","complex","Complex"]) || "");
    const getId     = (r) => String(safeGet(r, ["RowID","rowid","row_id","id","ID","structure_ID","pdb"]) || "");

    const selectedKinases = getSelectedValues(kinaseSelect);

    // 先依 mode + kinase filter 過濾
    let filtered = rows.slice();

    // 如果有選 kinase（任何模式都可以用），就過濾
    if (selectedKinases.length > 0){
      const set = new Set(selectedKinases.map(String));
      filtered = filtered.filter(r => set.has(getKinase(r)));
    }

    // y key 決定（kinase 模式：以 kinase；pdb 模式：以 pdb）
    // 但為了可對齊 docking pose：yLabel 會在後面縮短顯示
    const yKeyFn = (r) => {
      if (state.mode === "pdb"){
        // 優先 pdb；沒有就退 structure_ID；再不行就 RowID
        const p = getPdb(r);
        return p || getId(r) || "(unknown)";
      }
      // kinase mode
      return getKinase(r) || "(unknown)";
    };

    // x labels: IFP columns
    const x = ifpCols.map(c => c);

    // group rows by yKey
    const groups = new Map();
    for (const r of filtered){
      const yk = yKeyFn(r);
      if (!groups.has(yk)) groups.set(yk, []);
      groups.get(yk).push(r);
    }

    // y ordering: stable sort by yKey
    const yFull = Array.from(groups.keys()).sort((a,b) => String(a).localeCompare(String(b)));

    // For each y group, aggregate IFP by mean (or max) — here use mean for numeric/boolean-like values
    // If values are "true/false", "1/0", convert to 1/0
    function toNum(v){
      if (v === true) return 1;
      if (v === false) return 0;
      const s = String(v).trim().toLowerCase();
      if (s === "true") return 1;
      if (s === "false") return 0;
      const n = Number(s);
      return Number.isFinite(n) ? n : 0;
    }

    const z = yFull.map(yk => {
      const list = groups.get(yk) || [];
      return ifpCols.map(col => {
        if (list.length === 0) return 0;
        let sum = 0;
        for (const r of list) sum += toNum(r[col]);
        return sum / list.length;
      });
    });

    // y short labels for display (align docking pose)
    const maxLen = Number(yMaxLen.value || 14);
    const policy = yShortPolicy.value || "tail";
    const yShort = yFull.map(v => shortenLabel(v, maxLen, policy));

    // hover text: show full y + count
    const hoverY = yFull.map(v => `${v} (n=${(groups.get(v)||[]).length})`);

    return { x, yFull, yShort, hoverY, z, filteredCount: filtered.length, groupCount: yFull.length };
  }

  /******************************************************************
   * Render Plotly heatmap
   ******************************************************************/
  function renderHeatmap(){
    clearAlert();

    if (!state.rows || state.rows.length === 0){
      showAlert("尚未載入資料。請先上傳 Excel。");
      return;
    }
    if (!state.ifpCols || state.ifpCols.length === 0){
      showAlert("找不到 IFP_* 欄位。請確認 Excel 欄位名稱。");
      return;
    }

    // === GUARD REQUIRED BY YOU ===
    if (!guardPdbModeSelection()) return;

    const { x, yFull, yShort, hoverY, z, filteredCount, groupCount } = buildMatrix();

    if (groupCount === 0){
      showAlert("目前篩選條件下沒有可用資料。請調整 kinase 選擇或確認欄位內容。");
      return;
    }

    const cs = Number(cellSize.value || 16);
    const lm = Number(leftMargin.value || 140);

    // height based on rows
    const height = Math.min(900, Math.max(420, 140 + yFull.length * cs));

    // Plotly heatmap trace
    const trace = {
      type: "heatmap",
      x,
      y: yShort,  // 顯示短標籤
      z,
      zmin: 0,
      zmax: 1,
      hovertemplate:
        "<b>%{x}</b><br>" +
        "y: %{customdata}<br>" +
        "value: %{z:.3f}<extra></extra>",
      customdata: yShort.map((_, idx) => hoverY[idx]).map(v => v), // each row label -> full info
    };

    const layout = {
      margin: { l: lm, r: 20, t: 10, b: 90 },
      height,
      xaxis: {
        tickangle: -45,
        automargin: true,
        tickfont: { family: "ui-monospace, Menlo, Consolas, monospace", size: 11 },
      },
      yaxis: {
        automargin: false, // 我們用固定 left margin 來「鎖定」對齊感
        tickfont: { family: "ui-monospace, Menlo, Consolas, monospace", size: 11 },
      },
      font: { family: "system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Arial" },
      paper_bgcolor: "white",
      plot_bgcolor: "white",
    };

    const config = { responsive: true, displaylogo: false };

    Plotly.newPlot("heatmap", [trace], layout, config);

    setStatus(`Render 完成：${filteredCount} rows -> ${groupCount} groups（mode=${state.mode}）`);
    updateMeta();
  }

  function updateMeta(){
    const selected = getSelectedValues(kinaseSelect);
    const s = selected.length ? `kinase=${selected.join(", ")}` : "kinase=ALL";
    metaEl.textContent = `${state.loadedFileName || "(no file)"} | mode=${state.mode} | ${s}`;
  }

  /******************************************************************
   * Buttons
   ******************************************************************/
  renderBtn.addEventListener("click", renderHeatmap);

  resetBtn.addEventListener("click", () => {
    clearAlert();
    // keep file as-is (user may want to re-render), but reset UI
    setMode("kinase");
    Array.from(kinaseSelect.options).forEach(o => o.selected = false);
    updateKinaseCount();
    yMaxLen.value = 14;
    yShortPolicy.value = "tail";
    cellSize.value = 16;
    leftMargin.value = 140;
    setStatus("已重設設定（資料仍保留，可直接 Render）");
    updateMeta();
  });

  // Re-render on key settings change (optional but handy)
  [yMaxLen, yShortPolicy, cellSize, leftMargin].forEach(el => {
    el.addEventListener("change", () => {
      if (state.rows && state.rows.length) renderHeatmap();
    });
  });

  // Default empty plot
  Plotly.newPlot("heatmap", [{
    type:"heatmap",
    x:["IFP_0","IFP_1","IFP_2"],
    y:["(upload)"],
    z:[[0,0,0]],
    hoverinfo:"skip",
  }], {
    margin:{l:140,r:20,t:10,b:70},
    height: 420,
    paper_bgcolor:"white",
    plot_bgcolor:"white",
  }, {responsive:true, displaylogo:false});
</script>
</body>
</html>
